{"ast":null,"code":"import _slicedToArray from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _asyncToGenerator from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { concat, dataLength, dataSlice, hexlify, isHexString, getBigInt, getBytes, getNumber, isCallException, isError, makeError, assert, assertArgument, FetchRequest, toBeArray, toQuantity, defineProperties, EventPayload, resolveProperties, toUtf8String } from \"../utils/index.js\";\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport { formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse } from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport { PollingBlockSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber } from \"./subscriber-polling.js\";\n// Constants\nvar BN_2 = BigInt(2);\nvar MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n  return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n  return prefix + \":\" + JSON.stringify(value, function (k, v) {\n    if (v == null) {\n      return \"null\";\n    }\n    if (typeof v === \"bigint\") {\n      return \"bigint:\".concat(v.toString());\n    }\n    if (typeof v === \"string\") {\n      return v.toLowerCase();\n    }\n    // Sort object keys\n    if (typeof v === \"object\" && !Array.isArray(v)) {\n      var keys = Object.keys(v);\n      keys.sort();\n      return keys.reduce(function (accum, key) {\n        accum[key] = v[key];\n        return accum;\n      }, {});\n    }\n    return v;\n  });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport var UnmanagedSubscriber = /*#__PURE__*/function () {\n  /**\n   *  Create a new UnmanagedSubscriber with %%name%%.\n   */\n  function UnmanagedSubscriber(name) {\n    _classCallCheck(this, UnmanagedSubscriber);\n    /**\n     *  The name fof the event.\n     */\n    _defineProperty(this, \"name\", void 0);\n    defineProperties(this, {\n      name: name\n    });\n  }\n  _createClass(UnmanagedSubscriber, [{\n    key: \"start\",\n    value: function start() {}\n  }, {\n    key: \"stop\",\n    value: function stop() {}\n  }, {\n    key: \"pause\",\n    value: function pause(dropWhilePaused) {}\n  }, {\n    key: \"resume\",\n    value: function resume() {}\n  }]);\n  return UnmanagedSubscriber;\n}();\nfunction copy(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n  items = Array.from(new Set(items).values());\n  items.sort();\n  return items;\n}\nfunction getSubscription(_x, _x2) {\n  return _getSubscription.apply(this, arguments);\n}\nfunction _getSubscription() {\n  _getSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(_event, provider) {\n    var hash, event, _event2, filter, addresses, promises, addAddress;\n    return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n      while (1) switch (_context41.prev = _context41.next) {\n        case 0:\n          if (!(_event == null)) {\n            _context41.next = 2;\n            break;\n          }\n          throw new Error(\"invalid event\");\n        case 2:\n          // Normalize topic array info an EventFilter\n          if (Array.isArray(_event)) {\n            _event = {\n              topics: _event\n            };\n          }\n          if (!(typeof _event === \"string\")) {\n            _context41.next = 8;\n            break;\n          }\n          _context41.t0 = _event;\n          _context41.next = _context41.t0 === \"block\" ? 7 : _context41.t0 === \"pending\" ? 7 : _context41.t0 === \"debug\" ? 7 : _context41.t0 === \"error\" ? 7 : _context41.t0 === \"network\" ? 7 : 8;\n          break;\n        case 7:\n          return _context41.abrupt(\"return\", {\n            type: _event,\n            tag: _event\n          });\n        case 8:\n          if (!isHexString(_event, 32)) {\n            _context41.next = 11;\n            break;\n          }\n          hash = _event.toLowerCase();\n          return _context41.abrupt(\"return\", {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n              hash: hash\n            }),\n            hash: hash\n          });\n        case 11:\n          if (!_event.orphan) {\n            _context41.next = 14;\n            break;\n          }\n          event = _event; // @TODO: Should lowercase and whatnot things here instead of copy...\n          return _context41.abrupt(\"return\", {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n          });\n        case 14:\n          if (!(_event.address || _event.topics)) {\n            _context41.next = 27;\n            break;\n          }\n          _event2 = _event;\n          filter = {\n            topics: (_event2.topics || []).map(function (t) {\n              if (t == null) {\n                return null;\n              }\n              if (Array.isArray(t)) {\n                return concisify(t.map(function (t) {\n                  return t.toLowerCase();\n                }));\n              }\n              return t.toLowerCase();\n            })\n          };\n          if (!_event2.address) {\n            _context41.next = 26;\n            break;\n          }\n          addresses = [];\n          promises = [];\n          addAddress = function addAddress(addr) {\n            if (isHexString(addr)) {\n              addresses.push(addr);\n            } else {\n              promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {\n                return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n                  while (1) switch (_context40.prev = _context40.next) {\n                    case 0:\n                      _context40.t0 = addresses;\n                      _context40.next = 3;\n                      return resolveAddress(addr, provider);\n                    case 3:\n                      _context40.t1 = _context40.sent;\n                      _context40.t0.push.call(_context40.t0, _context40.t1);\n                    case 5:\n                    case \"end\":\n                      return _context40.stop();\n                  }\n                }, _callee40);\n              }))());\n            }\n          };\n          if (Array.isArray(_event2.address)) {\n            _event2.address.forEach(addAddress);\n          } else {\n            addAddress(_event2.address);\n          }\n          if (!promises.length) {\n            _context41.next = 25;\n            break;\n          }\n          _context41.next = 25;\n          return Promise.all(promises);\n        case 25:\n          filter.address = concisify(addresses.map(function (a) {\n            return a.toLowerCase();\n          }));\n        case 26:\n          return _context41.abrupt(\"return\", {\n            filter: filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n          });\n        case 27:\n          assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n        case 28:\n        case \"end\":\n          return _context41.stop();\n      }\n    }, _callee41);\n  }));\n  return _getSubscription.apply(this, arguments);\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nvar defaultOptions = {\n  cacheTimeout: 250,\n  pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nvar _subs = /*#__PURE__*/new WeakMap();\nvar _plugins = /*#__PURE__*/new WeakMap();\nvar _pausedState = /*#__PURE__*/new WeakMap();\nvar _destroyed = /*#__PURE__*/new WeakMap();\nvar _networkPromise = /*#__PURE__*/new WeakMap();\nvar _anyNetwork = /*#__PURE__*/new WeakMap();\nvar _performCache = /*#__PURE__*/new WeakMap();\nvar _lastBlockNumber = /*#__PURE__*/new WeakMap();\nvar _nextTimer = /*#__PURE__*/new WeakMap();\nvar _timers = /*#__PURE__*/new WeakMap();\nvar _disableCcipRead = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _perform = /*#__PURE__*/new WeakSet();\nvar _call = /*#__PURE__*/new WeakSet();\nvar _checkNetwork = /*#__PURE__*/new WeakSet();\nvar _getAccountValue = /*#__PURE__*/new WeakSet();\nvar _getBlock = /*#__PURE__*/new WeakSet();\nvar _hasSub = /*#__PURE__*/new WeakSet();\nvar _getSub = /*#__PURE__*/new WeakSet();\nexport var AbstractProvider = /*#__PURE__*/function () {\n  /**\n   *  Create a new **AbstractProvider** connected to %%network%%, or\n   *  use the various network detection capabilities to discover the\n   *  [[Network]] if necessary.\n   */\n  function AbstractProvider(_network, options) {\n    var _this = this;\n    _classCallCheck(this, AbstractProvider);\n    _classPrivateMethodInitSpec(this, _getSub);\n    _classPrivateMethodInitSpec(this, _hasSub);\n    _classPrivateMethodInitSpec(this, _getBlock);\n    // Account\n    _classPrivateMethodInitSpec(this, _getAccountValue);\n    _classPrivateMethodInitSpec(this, _checkNetwork);\n    _classPrivateMethodInitSpec(this, _call);\n    // Shares multiple identical requests made during the same 250ms\n    _classPrivateMethodInitSpec(this, _perform);\n    _classPrivateFieldInitSpec(this, _subs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _plugins, {\n      writable: true,\n      value: void 0\n    });\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    _classPrivateFieldInitSpec(this, _pausedState, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _destroyed, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _networkPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _anyNetwork, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _performCache, {\n      writable: true,\n      value: void 0\n    });\n    // The most recent block number if running an event or -1 if no \"block\" event\n    _classPrivateFieldInitSpec(this, _lastBlockNumber, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _nextTimer, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _timers, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disableCcipRead, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _options, Object.assign({}, defaultOptions, options || {}));\n    if (_network === \"any\") {\n      _classPrivateFieldSet(this, _anyNetwork, true);\n      _classPrivateFieldSet(this, _networkPromise, null);\n    } else if (_network) {\n      var network = Network.from(_network);\n      _classPrivateFieldSet(this, _anyNetwork, false);\n      _classPrivateFieldSet(this, _networkPromise, Promise.resolve(network));\n      setTimeout(function () {\n        _this.emit(\"network\", network, null);\n      }, 0);\n    } else {\n      _classPrivateFieldSet(this, _anyNetwork, false);\n      _classPrivateFieldSet(this, _networkPromise, null);\n    }\n    _classPrivateFieldSet(this, _lastBlockNumber, -1);\n    _classPrivateFieldSet(this, _performCache, new Map());\n    _classPrivateFieldSet(this, _subs, new Map());\n    _classPrivateFieldSet(this, _plugins, new Map());\n    _classPrivateFieldSet(this, _pausedState, null);\n    _classPrivateFieldSet(this, _destroyed, false);\n    _classPrivateFieldSet(this, _nextTimer, 1);\n    _classPrivateFieldSet(this, _timers, new Map());\n    _classPrivateFieldSet(this, _disableCcipRead, false);\n  }\n  _createClass(AbstractProvider, [{\n    key: \"pollingInterval\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _options).pollingInterval;\n    }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this;\n    }\n    /**\n     *  Returns all the registered plug-ins.\n     */\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return Array.from(_classPrivateFieldGet(this, _plugins).values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */\n  }, {\n    key: \"attachPlugin\",\n    value: function attachPlugin(plugin) {\n      if (_classPrivateFieldGet(this, _plugins).get(plugin.name)) {\n        throw new Error(\"cannot replace existing plugin: \".concat(plugin.name, \" \"));\n      }\n      _classPrivateFieldGet(this, _plugins).set(plugin.name, plugin.connect(this));\n      return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */\n  }, {\n    key: \"getPlugin\",\n    value: function getPlugin(name) {\n      return _classPrivateFieldGet(this, _plugins).get(name) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n  }, {\n    key: \"disableCcipRead\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _disableCcipRead);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _disableCcipRead, !!value);\n    }\n  }, {\n    key: \"ccipReadFetch\",\n    value:\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    function () {\n      var _ccipReadFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx, calldata, urls) {\n        var sender, data, errorMessages, i, url, href, request, errorMessage, resp, result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.disableCcipRead || urls.length === 0 || tx.to == null)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", null);\n            case 2:\n              sender = tx.to.toLowerCase();\n              data = calldata.toLowerCase();\n              errorMessages = [];\n              i = 0;\n            case 6:\n              if (!(i < urls.length)) {\n                _context.next = 32;\n                break;\n              }\n              url = urls[i]; // URL expansion\n              href = url.replace(\"{sender}\", sender).replace(\"{data}\", data); // If no {data} is present, use POST; otherwise GET\n              //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n              //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n              //    value.status = response.statusCode;\n              //    return value;\n              //});\n              request = new FetchRequest(href);\n              if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                  data: data,\n                  sender: sender\n                };\n              }\n              this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request: request,\n                index: i,\n                urls: urls\n              });\n              errorMessage = \"unknown error\";\n              _context.next = 15;\n              return request.send();\n            case 15:\n              resp = _context.sent;\n              _context.prev = 16;\n              result = resp.bodyJson;\n              if (!result.data) {\n                _context.next = 21;\n                break;\n              }\n              this.emit(\"debug\", {\n                action: \"receiveCcipReadFetchResult\",\n                request: request,\n                result: result\n              });\n              return _context.abrupt(\"return\", result.data);\n            case 21:\n              if (result.message) {\n                errorMessage = result.message;\n              }\n              this.emit(\"debug\", {\n                action: \"receiveCcipReadFetchError\",\n                request: request,\n                result: result\n              });\n              _context.next = 27;\n              break;\n            case 25:\n              _context.prev = 25;\n              _context.t0 = _context[\"catch\"](16);\n            case 27:\n              // 4xx indicates the result is not present; stop\n              assert(resp.statusCode < 400 || resp.statusCode >= 500, \"response not found during CCIP fetch: \".concat(errorMessage), \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                  url: url,\n                  errorMessage: errorMessage\n                }\n              });\n              // 5xx indicates server issue; try the next url\n              errorMessages.push(errorMessage);\n            case 29:\n              i++;\n              _context.next = 6;\n              break;\n            case 32:\n              assert(false, \"error encountered during CCIP fetch: \".concat(errorMessages.map(function (m) {\n                return JSON.stringify(m);\n              }).join(\", \")), \"OFFCHAIN_FAULT\", {\n                reason: \"500_SERVER_ERROR\",\n                transaction: tx,\n                info: {\n                  urls: urls,\n                  errorMessages: errorMessages\n                }\n              });\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[16, 25]]);\n      }));\n      function ccipReadFetch(_x3, _x4, _x5) {\n        return _ccipReadFetch.apply(this, arguments);\n      }\n      return ccipReadFetch;\n    }()\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n  }, {\n    key: \"_wrapBlock\",\n    value: function _wrapBlock(value, network) {\n      return new Block(formatBlock(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n  }, {\n    key: \"_wrapLog\",\n    value: function _wrapLog(value, network) {\n      return new Log(formatLog(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n  }, {\n    key: \"_wrapTransactionReceipt\",\n    value: function _wrapTransactionReceipt(value, network) {\n      return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n  }, {\n    key: \"_wrapTransactionResponse\",\n    value: function _wrapTransactionResponse(tx, network) {\n      return new TransactionResponse(formatTransactionResponse(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n  }, {\n    key: \"_detectNetwork\",\n    value: function _detectNetwork() {\n      assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"_detectNetwork\"\n      });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n  }, {\n    key: \"_perform\",\n    value: function () {\n      var _perform3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(req) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              assert(false, \"unsupported method: \".concat(req.method), \"UNSUPPORTED_OPERATION\", {\n                operation: req.method,\n                info: req\n              });\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function _perform(_x6) {\n        return _perform3.apply(this, arguments);\n      }\n      return _perform;\n    }() // State\n  }, {\n    key: \"getBlockNumber\",\n    value: function () {\n      var _getBlockNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var blockNumber;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.t0 = getNumber;\n              _context3.next = 3;\n              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                method: \"getBlockNumber\"\n              });\n            case 3:\n              _context3.t1 = _context3.sent;\n              blockNumber = (0, _context3.t0)(_context3.t1, \"%response\");\n              if (_classPrivateFieldGet(this, _lastBlockNumber) >= 0) {\n                _classPrivateFieldSet(this, _lastBlockNumber, blockNumber);\n              }\n              return _context3.abrupt(\"return\", blockNumber);\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getBlockNumber() {\n        return _getBlockNumber.apply(this, arguments);\n      }\n      return getBlockNumber;\n    }()\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n  }, {\n    key: \"_getAddress\",\n    value: function _getAddress(address) {\n      return resolveAddress(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n  }, {\n    key: \"_getBlockTag\",\n    value: function _getBlockTag(blockTag) {\n      if (blockTag == null) {\n        return \"latest\";\n      }\n      switch (blockTag) {\n        case \"earliest\":\n          return \"0x0\";\n        case \"latest\":\n        case \"pending\":\n        case \"safe\":\n        case \"finalized\":\n          return blockTag;\n      }\n      if (isHexString(blockTag)) {\n        if (isHexString(blockTag, 32)) {\n          return blockTag;\n        }\n        return toQuantity(blockTag);\n      }\n      if (typeof blockTag === \"bigint\") {\n        blockTag = getNumber(blockTag, \"blockTag\");\n      }\n      if (typeof blockTag === \"number\") {\n        if (blockTag >= 0) {\n          return toQuantity(blockTag);\n        }\n        if (_classPrivateFieldGet(this, _lastBlockNumber) >= 0) {\n          return toQuantity(_classPrivateFieldGet(this, _lastBlockNumber) + blockTag);\n        }\n        return this.getBlockNumber().then(function (b) {\n          return toQuantity(b + blockTag);\n        });\n      }\n      assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n  }, {\n    key: \"_getFilter\",\n    value: function _getFilter(filter) {\n      // Create a canonical representation of the topics\n      var topics = (filter.topics || []).map(function (t) {\n        if (t == null) {\n          return null;\n        }\n        if (Array.isArray(t)) {\n          return concisify(t.map(function (t) {\n            return t.toLowerCase();\n          }));\n        }\n        return t.toLowerCase();\n      });\n      var blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n      var resolve = function resolve(_address, fromBlock, toBlock) {\n        var address = undefined;\n        switch (_address.length) {\n          case 0:\n            break;\n          case 1:\n            address = _address[0];\n            break;\n          default:\n            _address.sort();\n            address = _address;\n        }\n        if (blockHash) {\n          if (fromBlock != null || toBlock != null) {\n            throw new Error(\"invalid filter\");\n          }\n        }\n        var filter = {};\n        if (address) {\n          filter.address = address;\n        }\n        if (topics.length) {\n          filter.topics = topics;\n        }\n        if (fromBlock) {\n          filter.fromBlock = fromBlock;\n        }\n        if (toBlock) {\n          filter.toBlock = toBlock;\n        }\n        if (blockHash) {\n          filter.blockHash = blockHash;\n        }\n        return filter;\n      };\n      // Addresses could be async (ENS names or Addressables)\n      var address = [];\n      if (filter.address) {\n        if (Array.isArray(filter.address)) {\n          var _iterator = _createForOfIteratorHelper(filter.address),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var addr = _step.value;\n              address.push(this._getAddress(addr));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          address.push(this._getAddress(filter.address));\n        }\n      }\n      var fromBlock = undefined;\n      if (\"fromBlock\" in filter) {\n        fromBlock = this._getBlockTag(filter.fromBlock);\n      }\n      var toBlock = undefined;\n      if (\"toBlock\" in filter) {\n        toBlock = this._getBlockTag(filter.toBlock);\n      }\n      if (address.filter(function (a) {\n        return typeof a !== \"string\";\n      }).length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n        return Promise.all([Promise.all(address), fromBlock, toBlock]).then(function (result) {\n          return resolve(result[0], result[1], result[2]);\n        });\n      }\n      return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resovles to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n  }, {\n    key: \"_getTransactionRequest\",\n    value: function _getTransactionRequest(_request) {\n      var request = copyRequest(_request);\n      var promises = [];\n      [\"to\", \"from\"].forEach(function (key) {\n        if (request[key] == null) {\n          return;\n        }\n        var addr = resolveAddress(request[key]);\n        if (isPromise(addr)) {\n          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return addr;\n                case 2:\n                  request[key] = _context4.sent;\n                case 3:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4);\n          }))());\n        } else {\n          request[key] = addr;\n        }\n      });\n      if (request.blockTag != null) {\n        var blockTag = this._getBlockTag(request.blockTag);\n        if (isPromise(blockTag)) {\n          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n            return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n              while (1) switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return blockTag;\n                case 2:\n                  request.blockTag = _context5.sent;\n                case 3:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }, _callee5);\n          }))());\n        } else {\n          request.blockTag = blockTag;\n        }\n      }\n      if (promises.length) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return Promise.all(promises);\n              case 2:\n                return _context6.abrupt(\"return\", request);\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6);\n        }))();\n      }\n      return request;\n    }\n  }, {\n    key: \"getNetwork\",\n    value: function () {\n      var _getNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _this2 = this;\n        var detectNetwork, networkPromise, _yield$Promise$all, _yield$Promise$all2, expected, actual;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(_classPrivateFieldGet(this, _networkPromise) == null)) {\n                _context7.next = 6;\n                break;\n              }\n              // Detect the current network (shared with all calls)\n              detectNetwork = this._detectNetwork().then(function (network) {\n                _this2.emit(\"network\", network, null);\n                return network;\n              }, function (error) {\n                // Reset the networkPromise on failure, so we will try again\n                if (_classPrivateFieldGet(_this2, _networkPromise) === detectNetwork) {\n                  _classPrivateFieldSet(_this2, _networkPromise, null);\n                }\n                throw error;\n              });\n              _classPrivateFieldSet(this, _networkPromise, detectNetwork);\n              _context7.next = 5;\n              return detectNetwork;\n            case 5:\n              return _context7.abrupt(\"return\", _context7.sent.clone());\n            case 6:\n              networkPromise = _classPrivateFieldGet(this, _networkPromise);\n              _context7.next = 9;\n              return Promise.all([networkPromise, this._detectNetwork() // The actual connected network\n              ]);\n            case 9:\n              _yield$Promise$all = _context7.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              expected = _yield$Promise$all2[0];\n              actual = _yield$Promise$all2[1];\n              if (expected.chainId !== actual.chainId) {\n                if (_classPrivateFieldGet(this, _anyNetwork)) {\n                  // The \"any\" network can change, so notify listeners\n                  this.emit(\"network\", actual, expected);\n                  // Update the network if something else hasn't already changed it\n                  if (_classPrivateFieldGet(this, _networkPromise) === networkPromise) {\n                    _classPrivateFieldSet(this, _networkPromise, Promise.resolve(actual));\n                  }\n                } else {\n                  // Otherwise, we do not allow changes to the underlying network\n                  assert(false, \"network changed: \".concat(expected.chainId, \" => \").concat(actual.chainId, \" \"), \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                  });\n                }\n              }\n              return _context7.abrupt(\"return\", expected.clone());\n            case 15:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getNetwork() {\n        return _getNetwork.apply(this, arguments);\n      }\n      return getNetwork;\n    }()\n  }, {\n    key: \"getFeeData\",\n    value: function () {\n      var _getFeeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _this3 = this;\n        var network, getFeeDataFunc, plugin, req, feeData;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return this.getNetwork();\n            case 2:\n              network = _context10.sent;\n              getFeeDataFunc = /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n                  var _yield$resolvePropert, _block, gasPrice, maxFeePerGas, maxPriorityFeePerGas, block;\n                  return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                    while (1) switch (_context9.prev = _context9.next) {\n                      case 0:\n                        _context9.next = 2;\n                        return resolveProperties({\n                          _block: _classPrivateMethodGet(_this3, _getBlock, _getBlock2).call(_this3, \"latest\", false),\n                          gasPrice: _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n                            var _gasPrice;\n                            return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                              while (1) switch (_context8.prev = _context8.next) {\n                                case 0:\n                                  _context8.prev = 0;\n                                  _context8.next = 3;\n                                  return _classPrivateMethodGet(_this3, _perform, _perform2).call(_this3, {\n                                    method: \"getGasPrice\"\n                                  });\n                                case 3:\n                                  _gasPrice = _context8.sent;\n                                  return _context8.abrupt(\"return\", getBigInt(_gasPrice, \"%response\"));\n                                case 7:\n                                  _context8.prev = 7;\n                                  _context8.t0 = _context8[\"catch\"](0);\n                                case 9:\n                                  return _context8.abrupt(\"return\", null);\n                                case 10:\n                                case \"end\":\n                                  return _context8.stop();\n                              }\n                            }, _callee8, null, [[0, 7]]);\n                          }))()\n                        });\n                      case 2:\n                        _yield$resolvePropert = _context9.sent;\n                        _block = _yield$resolvePropert._block;\n                        gasPrice = _yield$resolvePropert.gasPrice;\n                        maxFeePerGas = null;\n                        maxPriorityFeePerGas = null; // These are the recommended EIP-1559 heuristics for fee data\n                        block = _this3._wrapBlock(_block, network);\n                        if (block && block.baseFeePerGas) {\n                          maxPriorityFeePerGas = BigInt(\"1000000000\");\n                          maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n                        }\n                        return _context9.abrupt(\"return\", new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas));\n                      case 10:\n                      case \"end\":\n                        return _context9.stop();\n                    }\n                  }, _callee9);\n                }));\n                return function getFeeDataFunc() {\n                  return _ref4.apply(this, arguments);\n                };\n              }(); // Check for a FeeDataNetWorkPlugin\n              plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n              if (!plugin) {\n                _context10.next = 11;\n                break;\n              }\n              req = new FetchRequest(plugin.url);\n              _context10.next = 9;\n              return plugin.processFunc(getFeeDataFunc, this, req);\n            case 9:\n              feeData = _context10.sent;\n              return _context10.abrupt(\"return\", new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas));\n            case 11:\n              _context10.next = 13;\n              return getFeeDataFunc();\n            case 13:\n              return _context10.abrupt(\"return\", _context10.sent);\n            case 14:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function getFeeData() {\n        return _getFeeData.apply(this, arguments);\n      }\n      return getFeeData;\n    }()\n  }, {\n    key: \"estimateGas\",\n    value: function () {\n      var _estimateGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_tx) {\n        var tx;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              tx = this._getTransactionRequest(_tx);\n              if (!isPromise(tx)) {\n                _context11.next = 5;\n                break;\n              }\n              _context11.next = 4;\n              return tx;\n            case 4:\n              tx = _context11.sent;\n            case 5:\n              _context11.t0 = getBigInt;\n              _context11.next = 8;\n              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                method: \"estimateGas\",\n                transaction: tx\n              });\n            case 8:\n              _context11.t1 = _context11.sent;\n              return _context11.abrupt(\"return\", (0, _context11.t0)(_context11.t1, \"%response\"));\n            case 10:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function estimateGas(_x7) {\n        return _estimateGas.apply(this, arguments);\n      }\n      return estimateGas;\n    }()\n  }, {\n    key: \"call\",\n    value: function () {\n      var _call3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_tx) {\n        var _yield$resolvePropert2, tx, blockTag;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return resolveProperties({\n                tx: this._getTransactionRequest(_tx),\n                blockTag: this._getBlockTag(_tx.blockTag)\n              });\n            case 2:\n              _yield$resolvePropert2 = _context12.sent;\n              tx = _yield$resolvePropert2.tx;\n              blockTag = _yield$resolvePropert2.blockTag;\n              _context12.next = 7;\n              return _classPrivateMethodGet(this, _checkNetwork, _checkNetwork2).call(this, _classPrivateMethodGet(this, _call, _call2).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n            case 7:\n              return _context12.abrupt(\"return\", _context12.sent);\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function call(_x8) {\n        return _call3.apply(this, arguments);\n      }\n      return call;\n    }()\n  }, {\n    key: \"getBalance\",\n    value: function () {\n      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(address, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.t0 = getBigInt;\n              _context13.next = 3;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getBalance\"\n              }, address, blockTag);\n            case 3:\n              _context13.t1 = _context13.sent;\n              return _context13.abrupt(\"return\", (0, _context13.t0)(_context13.t1, \"%response\"));\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getBalance(_x9, _x10) {\n        return _getBalance.apply(this, arguments);\n      }\n      return getBalance;\n    }()\n  }, {\n    key: \"getTransactionCount\",\n    value: function () {\n      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(address, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.t0 = getNumber;\n              _context14.next = 3;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getTransactionCount\"\n              }, address, blockTag);\n            case 3:\n              _context14.t1 = _context14.sent;\n              return _context14.abrupt(\"return\", (0, _context14.t0)(_context14.t1, \"%response\"));\n            case 5:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function getTransactionCount(_x11, _x12) {\n        return _getTransactionCount.apply(this, arguments);\n      }\n      return getTransactionCount;\n    }()\n  }, {\n    key: \"getCode\",\n    value: function () {\n      var _getCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(address, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.t0 = hexlify;\n              _context15.next = 3;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getCode\"\n              }, address, blockTag);\n            case 3:\n              _context15.t1 = _context15.sent;\n              return _context15.abrupt(\"return\", (0, _context15.t0)(_context15.t1));\n            case 5:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function getCode(_x13, _x14) {\n        return _getCode.apply(this, arguments);\n      }\n      return getCode;\n    }()\n  }, {\n    key: \"getStorage\",\n    value: function () {\n      var _getStorage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(address, _position, blockTag) {\n        var position;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              position = getBigInt(_position, \"position\");\n              _context16.t0 = hexlify;\n              _context16.next = 4;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getStorage\",\n                position: position\n              }, address, blockTag);\n            case 4:\n              _context16.t1 = _context16.sent;\n              return _context16.abrupt(\"return\", (0, _context16.t0)(_context16.t1));\n            case 6:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function getStorage(_x15, _x16, _x17) {\n        return _getStorage.apply(this, arguments);\n      }\n      return getStorage;\n    }() // Write\n  }, {\n    key: \"broadcastTransaction\",\n    value: function () {\n      var _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(signedTx) {\n        var _yield$resolvePropert3, blockNumber, hash, network, tx;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return resolveProperties({\n                blockNumber: this.getBlockNumber(),\n                hash: this._perform({\n                  method: \"broadcastTransaction\",\n                  signedTransaction: signedTx\n                }),\n                network: this.getNetwork()\n              });\n            case 2:\n              _yield$resolvePropert3 = _context17.sent;\n              blockNumber = _yield$resolvePropert3.blockNumber;\n              hash = _yield$resolvePropert3.hash;\n              network = _yield$resolvePropert3.network;\n              tx = Transaction.from(signedTx);\n              if (!(tx.hash !== hash)) {\n                _context17.next = 9;\n                break;\n              }\n              throw new Error(\"@TODO: the returned hash did not match\");\n            case 9:\n              return _context17.abrupt(\"return\", this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber));\n            case 10:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function broadcastTransaction(_x18) {\n        return _broadcastTransaction.apply(this, arguments);\n      }\n      return broadcastTransaction;\n    }()\n  }, {\n    key: \"getBlock\",\n    value: // Queries\n    function () {\n      var _getBlock3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(block, prefetchTxs) {\n        var _yield$resolvePropert4, network, params;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _getBlock, _getBlock2).call(this, block, !!prefetchTxs)\n              });\n            case 2:\n              _yield$resolvePropert4 = _context18.sent;\n              network = _yield$resolvePropert4.network;\n              params = _yield$resolvePropert4.params;\n              if (!(params == null)) {\n                _context18.next = 7;\n                break;\n              }\n              return _context18.abrupt(\"return\", null);\n            case 7:\n              return _context18.abrupt(\"return\", this._wrapBlock(params, network));\n            case 8:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function getBlock(_x19, _x20) {\n        return _getBlock3.apply(this, arguments);\n      }\n      return getBlock;\n    }()\n  }, {\n    key: \"getTransaction\",\n    value: function () {\n      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(hash) {\n        var _yield$resolvePropert5, network, params;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getTransaction\",\n                  hash: hash\n                })\n              });\n            case 2:\n              _yield$resolvePropert5 = _context19.sent;\n              network = _yield$resolvePropert5.network;\n              params = _yield$resolvePropert5.params;\n              if (!(params == null)) {\n                _context19.next = 7;\n                break;\n              }\n              return _context19.abrupt(\"return\", null);\n            case 7:\n              return _context19.abrupt(\"return\", this._wrapTransactionResponse(params, network));\n            case 8:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function getTransaction(_x21) {\n        return _getTransaction.apply(this, arguments);\n      }\n      return getTransaction;\n    }()\n  }, {\n    key: \"getTransactionReceipt\",\n    value: function () {\n      var _getTransactionReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(hash) {\n        var _yield$resolvePropert6, network, params, tx;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getTransactionReceipt\",\n                  hash: hash\n                })\n              });\n            case 2:\n              _yield$resolvePropert6 = _context20.sent;\n              network = _yield$resolvePropert6.network;\n              params = _yield$resolvePropert6.params;\n              if (!(params == null)) {\n                _context20.next = 7;\n                break;\n              }\n              return _context20.abrupt(\"return\", null);\n            case 7:\n              if (!(params.gasPrice == null && params.effectiveGasPrice == null)) {\n                _context20.next = 14;\n                break;\n              }\n              _context20.next = 10;\n              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                method: \"getTransaction\",\n                hash: hash\n              });\n            case 10:\n              tx = _context20.sent;\n              if (!(tx == null)) {\n                _context20.next = 13;\n                break;\n              }\n              throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            case 13:\n              params.effectiveGasPrice = tx.gasPrice;\n            case 14:\n              return _context20.abrupt(\"return\", this._wrapTransactionReceipt(params, network));\n            case 15:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function getTransactionReceipt(_x22) {\n        return _getTransactionReceipt.apply(this, arguments);\n      }\n      return getTransactionReceipt;\n    }()\n  }, {\n    key: \"getTransactionResult\",\n    value: function () {\n      var _getTransactionResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(hash) {\n        var _yield$resolvePropert7, result;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                result: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getTransactionResult\",\n                  hash: hash\n                })\n              });\n            case 2:\n              _yield$resolvePropert7 = _context21.sent;\n              result = _yield$resolvePropert7.result;\n              if (!(result == null)) {\n                _context21.next = 6;\n                break;\n              }\n              return _context21.abrupt(\"return\", null);\n            case 6:\n              return _context21.abrupt(\"return\", hexlify(result));\n            case 7:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function getTransactionResult(_x23) {\n        return _getTransactionResult.apply(this, arguments);\n      }\n      return getTransactionResult;\n    }() // Bloom-filter Queries\n  }, {\n    key: \"getLogs\",\n    value: function () {\n      var _getLogs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(_filter) {\n        var _this4 = this;\n        var filter, _yield$resolvePropert8, network, params;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              filter = this._getFilter(_filter);\n              if (!isPromise(filter)) {\n                _context22.next = 5;\n                break;\n              }\n              _context22.next = 4;\n              return filter;\n            case 4:\n              filter = _context22.sent;\n            case 5:\n              _context22.next = 7;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getLogs\",\n                  filter: filter\n                })\n              });\n            case 7:\n              _yield$resolvePropert8 = _context22.sent;\n              network = _yield$resolvePropert8.network;\n              params = _yield$resolvePropert8.params;\n              return _context22.abrupt(\"return\", params.map(function (p) {\n                return _this4._wrapLog(p, network);\n              }));\n            case 11:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function getLogs(_x24) {\n        return _getLogs.apply(this, arguments);\n      }\n      return getLogs;\n    }() // ENS\n  }, {\n    key: \"_getProvider\",\n    value: function _getProvider(chainId) {\n      assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"_getProvider()\"\n      });\n    }\n  }, {\n    key: \"getResolver\",\n    value: function () {\n      var _getResolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(name) {\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.next = 2;\n              return EnsResolver.fromName(this, name);\n            case 2:\n              return _context23.abrupt(\"return\", _context23.sent);\n            case 3:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function getResolver(_x25) {\n        return _getResolver.apply(this, arguments);\n      }\n      return getResolver;\n    }()\n  }, {\n    key: \"getAvatar\",\n    value: function () {\n      var _getAvatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(name) {\n        var resolver;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return this.getResolver(name);\n            case 2:\n              resolver = _context24.sent;\n              if (!resolver) {\n                _context24.next = 7;\n                break;\n              }\n              _context24.next = 6;\n              return resolver.getAvatar();\n            case 6:\n              return _context24.abrupt(\"return\", _context24.sent);\n            case 7:\n              return _context24.abrupt(\"return\", null);\n            case 8:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function getAvatar(_x26) {\n        return _getAvatar.apply(this, arguments);\n      }\n      return getAvatar;\n    }()\n  }, {\n    key: \"resolveName\",\n    value: function () {\n      var _resolveName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(name) {\n        var resolver;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              _context25.next = 2;\n              return this.getResolver(name);\n            case 2:\n              resolver = _context25.sent;\n              if (!resolver) {\n                _context25.next = 7;\n                break;\n              }\n              _context25.next = 6;\n              return resolver.getAddress();\n            case 6:\n              return _context25.abrupt(\"return\", _context25.sent);\n            case 7:\n              return _context25.abrupt(\"return\", null);\n            case 8:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function resolveName(_x27) {\n        return _resolveName.apply(this, arguments);\n      }\n      return resolveName;\n    }()\n  }, {\n    key: \"lookupAddress\",\n    value: function () {\n      var _lookupAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(address) {\n        var node, ensAddr, ensContract, resolver, resolverContract, name, check;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              address = getAddress(address);\n              node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n              _context26.prev = 2;\n              _context26.next = 5;\n              return EnsResolver.getEnsAddress(this);\n            case 5:\n              ensAddr = _context26.sent;\n              ensContract = new Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], this);\n              _context26.next = 9;\n              return ensContract.resolver(node);\n            case 9:\n              resolver = _context26.sent;\n              if (!(resolver == null || resolver === ZeroAddress)) {\n                _context26.next = 12;\n                break;\n              }\n              return _context26.abrupt(\"return\", null);\n            case 12:\n              resolverContract = new Contract(resolver, [\"function name(bytes32) view returns (string)\"], this);\n              _context26.next = 15;\n              return resolverContract.name(node);\n            case 15:\n              name = _context26.sent;\n              _context26.next = 18;\n              return this.resolveName(name);\n            case 18:\n              check = _context26.sent;\n              if (!(check !== address)) {\n                _context26.next = 21;\n                break;\n              }\n              return _context26.abrupt(\"return\", null);\n            case 21:\n              return _context26.abrupt(\"return\", name);\n            case 24:\n              _context26.prev = 24;\n              _context26.t0 = _context26[\"catch\"](2);\n              if (!(isError(_context26.t0, \"BAD_DATA\") && _context26.t0.value === \"0x\")) {\n                _context26.next = 28;\n                break;\n              }\n              return _context26.abrupt(\"return\", null);\n            case 28:\n              if (!isError(_context26.t0, \"CALL_EXCEPTION\")) {\n                _context26.next = 30;\n                break;\n              }\n              return _context26.abrupt(\"return\", null);\n            case 30:\n              throw _context26.t0;\n            case 31:\n              return _context26.abrupt(\"return\", null);\n            case 32:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this, [[2, 24]]);\n      }));\n      function lookupAddress(_x28) {\n        return _lookupAddress.apply(this, arguments);\n      }\n      return lookupAddress;\n    }()\n  }, {\n    key: \"waitForTransaction\",\n    value: function () {\n      var _waitForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(hash, _confirms, timeout) {\n        var _this5 = this;\n        var confirms;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              confirms = _confirms != null ? _confirms : 1;\n              if (!(confirms === 0)) {\n                _context29.next = 3;\n                break;\n              }\n              return _context29.abrupt(\"return\", this.getTransactionReceipt(hash));\n            case 3:\n              return _context29.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n                var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(resolve, reject) {\n                  var timer, listener;\n                  return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n                    while (1) switch (_context28.prev = _context28.next) {\n                      case 0:\n                        timer = null;\n                        listener = /*#__PURE__*/function () {\n                          var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(blockNumber) {\n                            var receipt;\n                            return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n                              while (1) switch (_context27.prev = _context27.next) {\n                                case 0:\n                                  _context27.prev = 0;\n                                  _context27.next = 3;\n                                  return _this5.getTransactionReceipt(hash);\n                                case 3:\n                                  receipt = _context27.sent;\n                                  if (!(receipt != null)) {\n                                    _context27.next = 9;\n                                    break;\n                                  }\n                                  if (!(blockNumber - receipt.blockNumber + 1 >= confirms)) {\n                                    _context27.next = 9;\n                                    break;\n                                  }\n                                  resolve(receipt);\n                                  //this.off(\"block\", listener);\n                                  if (timer) {\n                                    clearTimeout(timer);\n                                    timer = null;\n                                  }\n                                  return _context27.abrupt(\"return\");\n                                case 9:\n                                  _context27.next = 14;\n                                  break;\n                                case 11:\n                                  _context27.prev = 11;\n                                  _context27.t0 = _context27[\"catch\"](0);\n                                  console.log(\"EEE\", _context27.t0);\n                                case 14:\n                                  _this5.once(\"block\", listener);\n                                case 15:\n                                case \"end\":\n                                  return _context27.stop();\n                              }\n                            }, _callee27, null, [[0, 11]]);\n                          }));\n                          return function listener(_x34) {\n                            return _ref7.apply(this, arguments);\n                          };\n                        }();\n                        if (timeout != null) {\n                          timer = setTimeout(function () {\n                            if (timer == null) {\n                              return;\n                            }\n                            timer = null;\n                            _this5.off(\"block\", listener);\n                            reject(makeError(\"timeout\", \"TIMEOUT\", {\n                              reason: \"timeout\"\n                            }));\n                          }, timeout);\n                        }\n                        _context28.t0 = listener;\n                        _context28.next = 6;\n                        return _this5.getBlockNumber();\n                      case 6:\n                        _context28.t1 = _context28.sent;\n                        (0, _context28.t0)(_context28.t1);\n                      case 8:\n                      case \"end\":\n                        return _context28.stop();\n                    }\n                  }, _callee28);\n                }));\n                return function (_x32, _x33) {\n                  return _ref6.apply(this, arguments);\n                };\n              }()));\n            case 4:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n      function waitForTransaction(_x29, _x30, _x31) {\n        return _waitForTransaction.apply(this, arguments);\n      }\n      return waitForTransaction;\n    }()\n  }, {\n    key: \"waitForBlock\",\n    value: function () {\n      var _waitForBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(blockTag) {\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n                operation: \"waitForBlock\"\n              });\n            case 1:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30);\n      }));\n      function waitForBlock(_x35) {\n        return _waitForBlock.apply(this, arguments);\n      }\n      return waitForBlock;\n    }()\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n  }, {\n    key: \"_clearTimeout\",\n    value: function _clearTimeout(timerId) {\n      var timer = _classPrivateFieldGet(this, _timers).get(timerId);\n      if (!timer) {\n        return;\n      }\n      if (timer.timer) {\n        clearTimeout(timer.timer);\n      }\n      _classPrivateFieldGet(this, _timers).delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n  }, {\n    key: \"_setTimeout\",\n    value: function _setTimeout(_func, timeout) {\n      var _this$nextTimer,\n        _this$nextTimer2,\n        _this6 = this;\n      if (timeout == null) {\n        timeout = 0;\n      }\n      var timerId = (_classPrivateFieldSet(this, _nextTimer, (_this$nextTimer = _classPrivateFieldGet(this, _nextTimer), _this$nextTimer2 = _this$nextTimer++, _this$nextTimer)), _this$nextTimer2);\n      var func = function func() {\n        _classPrivateFieldGet(_this6, _timers).delete(timerId);\n        _func();\n      };\n      if (this.paused) {\n        _classPrivateFieldGet(this, _timers).set(timerId, {\n          timer: null,\n          func: func,\n          time: timeout\n        });\n      } else {\n        var timer = setTimeout(func, timeout);\n        _classPrivateFieldGet(this, _timers).set(timerId, {\n          timer: timer,\n          func: func,\n          time: getTime()\n        });\n      }\n      return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n  }, {\n    key: \"_forEachSubscriber\",\n    value: function _forEachSubscriber(func) {\n      var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var sub = _step2.value;\n          func(sub.subscriber);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n  }, {\n    key: \"_getSubscriber\",\n    value: function _getSubscriber(sub) {\n      switch (sub.type) {\n        case \"debug\":\n        case \"error\":\n        case \"network\":\n          return new UnmanagedSubscriber(sub.type);\n        case \"block\":\n          {\n            var subscriber = new PollingBlockSubscriber(this);\n            subscriber.pollingInterval = this.pollingInterval;\n            return subscriber;\n          }\n        case \"event\":\n          return new PollingEventSubscriber(this, sub.filter);\n        case \"transaction\":\n          return new PollingTransactionSubscriber(this, sub.hash);\n        case \"orphan\":\n          return new PollingOrphanSubscriber(this, sub.filter);\n      }\n      throw new Error(\"unsupported event: \".concat(sub.type));\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n  }, {\n    key: \"_recoverSubscriber\",\n    value: function _recoverSubscriber(oldSub, newSub) {\n      var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values()),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var sub = _step3.value;\n          if (sub.subscriber === oldSub) {\n            if (sub.started) {\n              sub.subscriber.stop();\n            }\n            sub.subscriber = newSub;\n            if (sub.started) {\n              newSub.start();\n            }\n            if (_classPrivateFieldGet(this, _pausedState) != null) {\n              newSub.pause(_classPrivateFieldGet(this, _pausedState));\n            }\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function () {\n      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              _context31.next = 2;\n              return _classPrivateMethodGet(this, _getSub, _getSub2).call(this, event);\n            case 2:\n              sub = _context31.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: false\n              });\n              if (!sub.started) {\n                sub.subscriber.start();\n                sub.started = true;\n                if (_classPrivateFieldGet(this, _pausedState) != null) {\n                  sub.subscriber.pause(_classPrivateFieldGet(this, _pausedState));\n                }\n              }\n              return _context31.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this);\n      }));\n      function on(_x36, _x37) {\n        return _on.apply(this, arguments);\n      }\n      return on;\n    }()\n  }, {\n    key: \"once\",\n    value: function () {\n      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              _context32.next = 2;\n              return _classPrivateMethodGet(this, _getSub, _getSub2).call(this, event);\n            case 2:\n              sub = _context32.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: true\n              });\n              if (!sub.started) {\n                sub.subscriber.start();\n                sub.started = true;\n                if (_classPrivateFieldGet(this, _pausedState) != null) {\n                  sub.subscriber.pause(_classPrivateFieldGet(this, _pausedState));\n                }\n              }\n              return _context32.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee32, this);\n      }));\n      function once(_x38, _x39) {\n        return _once.apply(this, arguments);\n      }\n      return once;\n    }()\n  }, {\n    key: \"emit\",\n    value: function () {\n      var _emit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(event) {\n        var _this7 = this;\n        var _len,\n          args,\n          _key,\n          sub,\n          count,\n          _args33 = arguments;\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              for (_len = _args33.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = _args33[_key];\n              }\n              _context33.next = 3;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event, args);\n            case 3:\n              sub = _context33.sent;\n              if (!(!sub || sub.listeners.length === 0)) {\n                _context33.next = 6;\n                break;\n              }\n              return _context33.abrupt(\"return\", false);\n            case 6:\n              ;\n              count = sub.listeners.length;\n              sub.listeners = sub.listeners.filter(function (_ref8) {\n                var listener = _ref8.listener,\n                  once = _ref8.once;\n                var payload = new EventPayload(_this7, once ? null : listener, event);\n                try {\n                  listener.call.apply(listener, [_this7].concat(args, [payload]));\n                } catch (error) {}\n                return !once;\n              });\n              if (sub.listeners.length === 0) {\n                if (sub.started) {\n                  sub.subscriber.stop();\n                }\n                _classPrivateFieldGet(this, _subs).delete(sub.tag);\n              }\n              return _context33.abrupt(\"return\", count > 0);\n            case 11:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33, this);\n      }));\n      function emit(_x40) {\n        return _emit.apply(this, arguments);\n      }\n      return emit;\n    }()\n  }, {\n    key: \"listenerCount\",\n    value: function () {\n      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(event) {\n        var sub, total, _iterator4, _step4, listeners;\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              if (!event) {\n                _context34.next = 7;\n                break;\n              }\n              _context34.next = 3;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event);\n            case 3:\n              sub = _context34.sent;\n              if (sub) {\n                _context34.next = 6;\n                break;\n              }\n              return _context34.abrupt(\"return\", 0);\n            case 6:\n              return _context34.abrupt(\"return\", sub.listeners.length);\n            case 7:\n              total = 0;\n              _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values());\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  listeners = _step4.value.listeners;\n                  total += listeners.length;\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n              return _context34.abrupt(\"return\", total);\n            case 11:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee34, this);\n      }));\n      function listenerCount(_x41) {\n        return _listenerCount.apply(this, arguments);\n      }\n      return listenerCount;\n    }()\n  }, {\n    key: \"listeners\",\n    value: function () {\n      var _listeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(event) {\n        var sub, result, _iterator5, _step5, _listeners2;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              if (!event) {\n                _context35.next = 7;\n                break;\n              }\n              _context35.next = 3;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event);\n            case 3:\n              sub = _context35.sent;\n              if (sub) {\n                _context35.next = 6;\n                break;\n              }\n              return _context35.abrupt(\"return\", []);\n            case 6:\n              return _context35.abrupt(\"return\", sub.listeners.map(function (_ref9) {\n                var listener = _ref9.listener;\n                return listener;\n              }));\n            case 7:\n              result = [];\n              _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values());\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  _listeners2 = _step5.value.listeners;\n                  result = result.concat(_listeners2.map(function (_ref10) {\n                    var listener = _ref10.listener;\n                    return listener;\n                  }));\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n              return _context35.abrupt(\"return\", result);\n            case 11:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n      function listeners(_x42) {\n        return _listeners.apply(this, arguments);\n      }\n      return listeners;\n    }()\n  }, {\n    key: \"off\",\n    value: function () {\n      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(event, listener) {\n        var sub, index;\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              _context36.next = 2;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event);\n            case 2:\n              sub = _context36.sent;\n              if (sub) {\n                _context36.next = 5;\n                break;\n              }\n              return _context36.abrupt(\"return\", this);\n            case 5:\n              if (listener) {\n                index = sub.listeners.map(function (_ref11) {\n                  var listener = _ref11.listener;\n                  return listener;\n                }).indexOf(listener);\n                if (index >= 0) {\n                  sub.listeners.splice(index, 1);\n                }\n              }\n              if (!listener || sub.listeners.length === 0) {\n                if (sub.started) {\n                  sub.subscriber.stop();\n                }\n                _classPrivateFieldGet(this, _subs).delete(sub.tag);\n              }\n              return _context36.abrupt(\"return\", this);\n            case 8:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee36, this);\n      }));\n      function off(_x43, _x44) {\n        return _off.apply(this, arguments);\n      }\n      return off;\n    }()\n  }, {\n    key: \"removeAllListeners\",\n    value: function () {\n      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(event) {\n        var _yield$_classPrivateM, tag, started, subscriber, _iterator6, _step6, _step6$value, _tag, _step6$value$, _started, _subscriber;\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) switch (_context37.prev = _context37.next) {\n            case 0:\n              if (!event) {\n                _context37.next = 11;\n                break;\n              }\n              _context37.next = 3;\n              return _classPrivateMethodGet(this, _getSub, _getSub2).call(this, event);\n            case 3:\n              _yield$_classPrivateM = _context37.sent;\n              tag = _yield$_classPrivateM.tag;\n              started = _yield$_classPrivateM.started;\n              subscriber = _yield$_classPrivateM.subscriber;\n              if (started) {\n                subscriber.stop();\n              }\n              _classPrivateFieldGet(this, _subs).delete(tag);\n              _context37.next = 13;\n              break;\n            case 11:\n              _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs));\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  _step6$value = _slicedToArray(_step6.value, 2), _tag = _step6$value[0], _step6$value$ = _step6$value[1], _started = _step6$value$.started, _subscriber = _step6$value$.subscriber;\n                  if (_started) {\n                    _subscriber.stop();\n                  }\n                  _classPrivateFieldGet(this, _subs).delete(_tag);\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n            case 13:\n              return _context37.abrupt(\"return\", this);\n            case 14:\n            case \"end\":\n              return _context37.stop();\n          }\n        }, _callee37, this);\n      }));\n      function removeAllListeners(_x45) {\n        return _removeAllListeners.apply(this, arguments);\n      }\n      return removeAllListeners;\n    }() // Alias for \"on\"\n  }, {\n    key: \"addListener\",\n    value: function () {\n      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) switch (_context38.prev = _context38.next) {\n            case 0:\n              _context38.next = 2;\n              return this.on(event, listener);\n            case 2:\n              return _context38.abrupt(\"return\", _context38.sent);\n            case 3:\n            case \"end\":\n              return _context38.stop();\n          }\n        }, _callee38, this);\n      }));\n      function addListener(_x46, _x47) {\n        return _addListener.apply(this, arguments);\n      }\n      return addListener;\n    }() // Alias for \"off\"\n  }, {\n    key: \"removeListener\",\n    value: function () {\n      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) switch (_context39.prev = _context39.next) {\n            case 0:\n              return _context39.abrupt(\"return\", this.off(event, listener));\n            case 1:\n            case \"end\":\n              return _context39.stop();\n          }\n        }, _callee39, this);\n      }));\n      function removeListener(_x48, _x49) {\n        return _removeListener.apply(this, arguments);\n      }\n      return removeListener;\n    }()\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _destroyed);\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // Stop all listeners\n      this.removeAllListeners();\n      // Shut down all tiemrs\n      var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).keys()),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var timerId = _step7.value;\n          this._clearTimeout(timerId);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      _classPrivateFieldSet(this, _destroyed, true);\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _pausedState) != null;\n    },\n    set: function set(pause) {\n      if (!!pause === this.paused) {\n        return;\n      }\n      if (this.paused) {\n        this.resume();\n      } else {\n        this.pause(false);\n      }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n  }, {\n    key: \"pause\",\n    value: function pause(dropWhilePaused) {\n      _classPrivateFieldSet(this, _lastBlockNumber, -1);\n      if (_classPrivateFieldGet(this, _pausedState) != null) {\n        if (_classPrivateFieldGet(this, _pausedState) == !!dropWhilePaused) {\n          return;\n        }\n        assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"pause\"\n        });\n      }\n      this._forEachSubscriber(function (s) {\n        return s.pause(dropWhilePaused);\n      });\n      _classPrivateFieldSet(this, _pausedState, !!dropWhilePaused);\n      var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).values()),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var timer = _step8.value;\n          // Clear the timer\n          if (timer.timer) {\n            clearTimeout(timer.timer);\n          }\n          // Remaining time needed for when we become unpaused\n          timer.time = getTime() - timer.time;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n    /**\n     *  Resume the provider.\n     */\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (_classPrivateFieldGet(this, _pausedState) == null) {\n        return;\n      }\n      this._forEachSubscriber(function (s) {\n        return s.resume();\n      });\n      _classPrivateFieldSet(this, _pausedState, null);\n      var _iterator9 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).values()),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var timer = _step9.value;\n          // Remaining time when we were paused\n          var timeout = timer.time;\n          if (timeout < 0) {\n            timeout = 0;\n          }\n          // Start time (in cause paused, so we con compute remaininf time)\n          timer.time = getTime();\n          // Start the timer\n          setTimeout(timer.func, timeout);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }]);\n  return AbstractProvider;\n}();\nfunction _perform2(_x50) {\n  return _perform4.apply(this, arguments);\n}\nfunction _perform4() {\n  _perform4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(req) {\n    var _this8 = this;\n    var timeout, tag, perform;\n    return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n      while (1) switch (_context42.prev = _context42.next) {\n        case 0:\n          timeout = _classPrivateFieldGet(this, _options).cacheTimeout; // Caching disabled\n          if (!(timeout < 0)) {\n            _context42.next = 5;\n            break;\n          }\n          _context42.next = 4;\n          return this._perform(req);\n        case 4:\n          return _context42.abrupt(\"return\", _context42.sent);\n        case 5:\n          // Create a tag\n          tag = getTag(req.method, req);\n          perform = _classPrivateFieldGet(this, _performCache).get(tag);\n          if (!perform) {\n            perform = this._perform(req);\n            _classPrivateFieldGet(this, _performCache).set(tag, perform);\n            setTimeout(function () {\n              if (_classPrivateFieldGet(_this8, _performCache).get(tag) === perform) {\n                _classPrivateFieldGet(_this8, _performCache).delete(tag);\n              }\n            }, timeout);\n          }\n          _context42.next = 10;\n          return perform;\n        case 10:\n          return _context42.abrupt(\"return\", _context42.sent);\n        case 11:\n        case \"end\":\n          return _context42.stop();\n      }\n    }, _callee42, this);\n  }));\n  return _perform4.apply(this, arguments);\n}\nfunction _call2(_x51, _x52, _x53) {\n  return _call4.apply(this, arguments);\n}\nfunction _call4() {\n  _call4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(tx, blockTag, attempt) {\n    var transaction, data, txSender, ccipArgs, ccipResult, _tx2, result;\n    return _regeneratorRuntime().wrap(function _callee43$(_context43) {\n      while (1) switch (_context43.prev = _context43.next) {\n        case 0:\n          assert(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, {\n              blockTag: blockTag,\n              enableCcipRead: true\n            })\n          });\n          // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n          transaction = copyRequest(tx);\n          _context43.prev = 2;\n          _context43.t0 = hexlify;\n          _context43.next = 6;\n          return this._perform({\n            method: \"call\",\n            transaction: transaction,\n            blockTag: blockTag\n          });\n        case 6:\n          _context43.t1 = _context43.sent;\n          return _context43.abrupt(\"return\", (0, _context43.t0)(_context43.t1));\n        case 10:\n          _context43.prev = 10;\n          _context43.t2 = _context43[\"catch\"](2);\n          if (!(!this.disableCcipRead && isCallException(_context43.t2) && _context43.t2.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(_context43.t2.data, 0, 4) === \"0x556f1830\")) {\n            _context43.next = 37;\n            break;\n          }\n          data = _context43.t2.data;\n          _context43.next = 16;\n          return resolveAddress(transaction.to, this);\n        case 16:\n          txSender = _context43.sent;\n          try {\n            ccipArgs = parseOffchainLookup(dataSlice(_context43.t2.data, 4));\n          } catch (error) {\n            assert(false, error.message, \"OFFCHAIN_FAULT\", {\n              reason: \"BAD_DATA\",\n              transaction: transaction,\n              info: {\n                data: data\n              }\n            });\n          }\n          // Check the sender of the OffchainLookup matches the transaction\n          assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n            action: \"call\",\n            data: data,\n            reason: \"OffchainLookup\",\n            transaction: transaction,\n            invocation: null,\n            revert: {\n              signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n              name: \"OffchainLookup\",\n              args: ccipArgs.errorArgs\n            }\n          });\n          _context43.next = 21;\n          return this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n        case 21:\n          ccipResult = _context43.sent;\n          assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n            reason: \"FETCH_FAILED\",\n            transaction: transaction,\n            info: {\n              data: _context43.t2.data,\n              errorArgs: ccipArgs.errorArgs\n            }\n          });\n          _tx2 = {\n            to: txSender,\n            data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n          };\n          this.emit(\"debug\", {\n            action: \"sendCcipReadCall\",\n            transaction: _tx2\n          });\n          _context43.prev = 25;\n          _context43.next = 28;\n          return _classPrivateMethodGet(this, _call, _call2).call(this, _tx2, blockTag, attempt + 1);\n        case 28:\n          result = _context43.sent;\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallResult\",\n            transaction: Object.assign({}, _tx2),\n            result: result\n          });\n          return _context43.abrupt(\"return\", result);\n        case 33:\n          _context43.prev = 33;\n          _context43.t3 = _context43[\"catch\"](25);\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallError\",\n            transaction: Object.assign({}, _tx2),\n            error: _context43.t3\n          });\n          throw _context43.t3;\n        case 37:\n          throw _context43.t2;\n        case 38:\n        case \"end\":\n          return _context43.stop();\n      }\n    }, _callee43, this, [[2, 10], [25, 33]]);\n  }));\n  return _call4.apply(this, arguments);\n}\nfunction _checkNetwork2(_x54) {\n  return _checkNetwork3.apply(this, arguments);\n}\nfunction _checkNetwork3() {\n  _checkNetwork3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(promise) {\n    var _yield$resolvePropert9, value;\n    return _regeneratorRuntime().wrap(function _callee44$(_context44) {\n      while (1) switch (_context44.prev = _context44.next) {\n        case 0:\n          _context44.next = 2;\n          return resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n          });\n        case 2:\n          _yield$resolvePropert9 = _context44.sent;\n          value = _yield$resolvePropert9.value;\n          return _context44.abrupt(\"return\", value);\n        case 5:\n        case \"end\":\n          return _context44.stop();\n      }\n    }, _callee44, this);\n  }));\n  return _checkNetwork3.apply(this, arguments);\n}\nfunction _getAccountValue2(_x55, _x56, _x57) {\n  return _getAccountValue3.apply(this, arguments);\n}\nfunction _getAccountValue3() {\n  _getAccountValue3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(request, _address, _blockTag) {\n    var address, blockTag, _yield$Promise$all3, _yield$Promise$all4;\n    return _regeneratorRuntime().wrap(function _callee45$(_context45) {\n      while (1) switch (_context45.prev = _context45.next) {\n        case 0:\n          address = this._getAddress(_address);\n          blockTag = this._getBlockTag(_blockTag);\n          if (!(typeof address !== \"string\" || typeof blockTag !== \"string\")) {\n            _context45.next = 9;\n            break;\n          }\n          _context45.next = 5;\n          return Promise.all([address, blockTag]);\n        case 5:\n          _yield$Promise$all3 = _context45.sent;\n          _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n          address = _yield$Promise$all4[0];\n          blockTag = _yield$Promise$all4[1];\n        case 9:\n          _context45.next = 11;\n          return _classPrivateMethodGet(this, _checkNetwork, _checkNetwork2).call(this, _classPrivateMethodGet(this, _perform, _perform2).call(this, Object.assign(request, {\n            address: address,\n            blockTag: blockTag\n          })));\n        case 11:\n          return _context45.abrupt(\"return\", _context45.sent);\n        case 12:\n        case \"end\":\n          return _context45.stop();\n      }\n    }, _callee45, this);\n  }));\n  return _getAccountValue3.apply(this, arguments);\n}\nfunction _getBlock2(_x58, _x59) {\n  return _getBlock4.apply(this, arguments);\n}\nfunction _getBlock4() {\n  _getBlock4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(block, includeTransactions) {\n    var blockTag;\n    return _regeneratorRuntime().wrap(function _callee46$(_context46) {\n      while (1) switch (_context46.prev = _context46.next) {\n        case 0:\n          if (!isHexString(block, 32)) {\n            _context46.next = 4;\n            break;\n          }\n          _context46.next = 3;\n          return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n            method: \"getBlock\",\n            blockHash: block,\n            includeTransactions: includeTransactions\n          });\n        case 3:\n          return _context46.abrupt(\"return\", _context46.sent);\n        case 4:\n          blockTag = this._getBlockTag(block);\n          if (!(typeof blockTag !== \"string\")) {\n            _context46.next = 9;\n            break;\n          }\n          _context46.next = 8;\n          return blockTag;\n        case 8:\n          blockTag = _context46.sent;\n        case 9:\n          _context46.next = 11;\n          return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n            method: \"getBlock\",\n            blockTag: blockTag,\n            includeTransactions: includeTransactions\n          });\n        case 11:\n          return _context46.abrupt(\"return\", _context46.sent);\n        case 12:\n        case \"end\":\n          return _context46.stop();\n      }\n    }, _callee46, this);\n  }));\n  return _getBlock4.apply(this, arguments);\n}\nfunction _hasSub2(_x60, _x61) {\n  return _hasSub3.apply(this, arguments);\n}\nfunction _hasSub3() {\n  _hasSub3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(event, emitArgs) {\n    var sub;\n    return _regeneratorRuntime().wrap(function _callee47$(_context47) {\n      while (1) switch (_context47.prev = _context47.next) {\n        case 0:\n          _context47.next = 2;\n          return getSubscription(event, this);\n        case 2:\n          sub = _context47.sent;\n          if (!(sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true)) {\n            _context47.next = 7;\n            break;\n          }\n          _context47.next = 6;\n          return getSubscription({\n            orphan: \"drop-log\",\n            log: emitArgs[0]\n          }, this);\n        case 6:\n          sub = _context47.sent;\n        case 7:\n          return _context47.abrupt(\"return\", _classPrivateFieldGet(this, _subs).get(sub.tag) || null);\n        case 8:\n        case \"end\":\n          return _context47.stop();\n      }\n    }, _callee47, this);\n  }));\n  return _hasSub3.apply(this, arguments);\n}\nfunction _getSub2(_x62) {\n  return _getSub3.apply(this, arguments);\n}\nfunction _getSub3() {\n  _getSub3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(event) {\n    var subscription, tag, sub, subscriber, addressableMap, nameMap;\n    return _regeneratorRuntime().wrap(function _callee48$(_context48) {\n      while (1) switch (_context48.prev = _context48.next) {\n        case 0:\n          _context48.next = 2;\n          return getSubscription(event, this);\n        case 2:\n          subscription = _context48.sent;\n          // Prevent tampering with our tag in any subclass' _getSubscriber\n          tag = subscription.tag;\n          sub = _classPrivateFieldGet(this, _subs).get(tag);\n          if (!sub) {\n            subscriber = this._getSubscriber(subscription);\n            addressableMap = new WeakMap();\n            nameMap = new Map();\n            sub = {\n              subscriber: subscriber,\n              tag: tag,\n              addressableMap: addressableMap,\n              nameMap: nameMap,\n              started: false,\n              listeners: []\n            };\n            _classPrivateFieldGet(this, _subs).set(tag, sub);\n          }\n          return _context48.abrupt(\"return\", sub);\n        case 7:\n        case \"end\":\n          return _context48.stop();\n      }\n    }, _callee48, this);\n  }));\n  return _getSub3.apply(this, arguments);\n}\nfunction _parseString(result, start) {\n  try {\n    var bytes = _parseBytes(result, start);\n    if (bytes) {\n      return toUtf8String(bytes);\n    }\n  } catch (error) {}\n  return null;\n}\nfunction _parseBytes(result, start) {\n  if (result === \"0x\") {\n    return null;\n  }\n  try {\n    var offset = getNumber(dataSlice(result, start, start + 32));\n    var length = getNumber(dataSlice(result, offset, offset + 32));\n    return dataSlice(result, offset + 32, offset + 32 + length);\n  } catch (error) {}\n  return null;\n}\nfunction numPad(value) {\n  var result = toBeArray(value);\n  if (result.length > 32) {\n    throw new Error(\"internal; should not happen\");\n  }\n  var padded = new Uint8Array(32);\n  padded.set(result, 32 - result.length);\n  return padded;\n}\nfunction bytesPad(value) {\n  if (value.length % 32 === 0) {\n    return value;\n  }\n  var result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n  result.set(value);\n  return result;\n}\nvar empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n  var result = [];\n  var byteCount = 0;\n  // Add place-holders for pointers as we add items\n  for (var i = 0; i < datas.length; i++) {\n    result.push(empty);\n    byteCount += 32;\n  }\n  for (var _i = 0; _i < datas.length; _i++) {\n    var data = getBytes(datas[_i]);\n    // Update the bytes offset\n    result[_i] = numPad(byteCount);\n    // The length and padded value of data\n    result.push(numPad(data.length));\n    result.push(bytesPad(data));\n    byteCount += 32 + Math.ceil(data.length / 32) * 32;\n  }\n  return concat(result);\n}\nvar zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n  var result = {\n    sender: \"\",\n    urls: [],\n    calldata: \"\",\n    selector: \"\",\n    extraData: \"\",\n    errorArgs: []\n  };\n  assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n    reason: \"insufficient OffchainLookup data\"\n  });\n  var sender = dataSlice(data, 0, 32);\n  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup sender\"\n  });\n  result.sender = dataSlice(sender, 12);\n  // Read the URLs from the response\n  try {\n    var urls = [];\n    var urlsOffset = getNumber(dataSlice(data, 32, 64));\n    var urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n    var urlsData = dataSlice(data, urlsOffset + 32);\n    for (var u = 0; u < urlsLength; u++) {\n      var url = _parseString(urlsData, u * 32);\n      if (url == null) {\n        throw new Error(\"abort\");\n      }\n      urls.push(url);\n    }\n    result.urls = urls;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup urls\"\n    });\n  }\n  // Get the CCIP calldata to forward\n  try {\n    var calldata = _parseBytes(data, 64);\n    if (calldata == null) {\n      throw new Error(\"abort\");\n    }\n    result.calldata = calldata;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup calldata\"\n    });\n  }\n  // Get the callbackSelector (bytes4)\n  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup callbaackSelector\"\n  });\n  result.selector = dataSlice(data, 96, 100);\n  // Get the extra data to send back to the contract as context\n  try {\n    var extraData = _parseBytes(data, 128);\n    if (extraData == null) {\n      throw new Error(\"abort\");\n    }\n    result.extraData = extraData;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup extraData\"\n    });\n  }\n  result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map(function (k) {\n    return result[k];\n  });\n  return result;\n}","map":{"version":3,"names":["getAddress","resolveAddress","ZeroAddress","Contract","namehash","Transaction","concat","dataLength","dataSlice","hexlify","isHexString","getBigInt","getBytes","getNumber","isCallException","isError","makeError","assert","assertArgument","FetchRequest","toBeArray","toQuantity","defineProperties","EventPayload","resolveProperties","toUtf8String","EnsResolver","formatBlock","formatLog","formatTransactionReceipt","formatTransactionResponse","Network","copyRequest","Block","FeeData","Log","TransactionReceipt","TransactionResponse","PollingBlockSubscriber","PollingEventSubscriber","PollingOrphanSubscriber","PollingTransactionSubscriber","BN_2","BigInt","MAX_CCIP_REDIRECTS","isPromise","value","then","getTag","prefix","JSON","stringify","k","v","toString","toLowerCase","Array","isArray","keys","Object","sort","reduce","accum","key","UnmanagedSubscriber","name","_classCallCheck","_defineProperty","_createClass","start","stop","pause","dropWhilePaused","resume","copy","parse","concisify","items","from","Set","values","getSubscription","_x","_x2","_getSubscription","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee41","_event","provider","hash","event","_event2","filter","addresses","promises","addAddress","wrap","_callee41$","_context41","prev","next","Error","topics","t0","abrupt","type","tag","orphan","address","map","t","addr","push","_callee40","_callee40$","_context40","t1","sent","call","forEach","length","Promise","all","a","getTime","Date","defaultOptions","cacheTimeout","pollingInterval","_subs","WeakMap","_plugins","_pausedState","_destroyed","_networkPromise","_anyNetwork","_performCache","_lastBlockNumber","_nextTimer","_timers","_disableCcipRead","_options","_perform","WeakSet","_call","_checkNetwork","_getAccountValue","_getBlock","_hasSub","_getSub","AbstractProvider","_network","options","_this","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","assign","network","resolve","setTimeout","emit","Map","get","_classPrivateFieldGet","attachPlugin","plugin","set","connect","getPlugin","_ccipReadFetch","_callee","tx","calldata","urls","sender","data","errorMessages","i","url","href","request","errorMessage","resp","result","_callee$","_context","disableCcipRead","to","replace","indexOf","body","action","index","send","bodyJson","message","statusCode","reason","transaction","info","m","join","ccipReadFetch","_x3","_x4","_x5","_wrapBlock","_wrapLog","_wrapTransactionReceipt","_wrapTransactionResponse","_detectNetwork","operation","_perform3","_callee2","req","_callee2$","_context2","method","_x6","_getBlockNumber","_callee3","blockNumber","_callee3$","_context3","_classPrivateMethodGet","_perform2","getBlockNumber","_getAddress","_getBlockTag","blockTag","b","_getFilter","blockHash","undefined","_address","fromBlock","toBlock","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","_getTransactionRequest","_request","_callee4","_callee4$","_context4","_callee5","_callee5$","_context5","_callee6","_callee6$","_context6","_getNetwork","_callee7","_this2","detectNetwork","networkPromise","_yield$Promise$all","_yield$Promise$all2","expected","actual","_callee7$","_context7","error","clone","_slicedToArray","chainId","getNetwork","_getFeeData","_callee10","_this3","getFeeDataFunc","feeData","_callee10$","_context10","_ref4","_callee9","_yield$resolvePropert","_block","gasPrice","maxFeePerGas","maxPriorityFeePerGas","block","_callee9$","_context9","_getBlock2","_callee8","_gasPrice","_callee8$","_context8","baseFeePerGas","processFunc","getFeeData","_estimateGas","_callee11","_tx","_callee11$","_context11","estimateGas","_x7","_call3","_callee12","_yield$resolvePropert2","_callee12$","_context12","_checkNetwork2","_call2","enableCcipRead","_x8","_getBalance","_callee13","_callee13$","_context13","_getAccountValue2","getBalance","_x9","_x10","_getTransactionCount","_callee14","_callee14$","_context14","getTransactionCount","_x11","_x12","_getCode","_callee15","_callee15$","_context15","getCode","_x13","_x14","_getStorage","_callee16","_position","position","_callee16$","_context16","getStorage","_x15","_x16","_x17","_broadcastTransaction","_callee17","signedTx","_yield$resolvePropert3","_callee17$","_context17","signedTransaction","replaceableTransaction","broadcastTransaction","_x18","_getBlock3","_callee18","prefetchTxs","_yield$resolvePropert4","params","_callee18$","_context18","getBlock","_x19","_x20","_getTransaction","_callee19","_yield$resolvePropert5","_callee19$","_context19","getTransaction","_x21","_getTransactionReceipt","_callee20","_yield$resolvePropert6","_callee20$","_context20","effectiveGasPrice","getTransactionReceipt","_x22","_getTransactionResult","_callee21","_yield$resolvePropert7","_callee21$","_context21","getTransactionResult","_x23","_getLogs","_callee22","_filter","_this4","_yield$resolvePropert8","_callee22$","_context22","p","getLogs","_x24","_getProvider","_getResolver","_callee23","_callee23$","_context23","fromName","getResolver","_x25","_getAvatar","_callee24","resolver","_callee24$","_context24","getAvatar","_x26","_resolveName","_callee25","_callee25$","_context25","resolveName","_x27","_lookupAddress","_callee26","node","ensAddr","ensContract","resolverContract","check","_callee26$","_context26","substring","getEnsAddress","lookupAddress","_x28","_waitForTransaction","_callee29","_confirms","timeout","_this5","confirms","_callee29$","_context29","_ref6","_callee28","reject","timer","listener","_callee28$","_context28","_ref7","_callee27","receipt","_callee27$","_context27","clearTimeout","console","log","once","_x34","off","_x32","_x33","waitForTransaction","_x29","_x30","_x31","_waitForBlock","_callee30","_callee30$","_context30","waitForBlock","_x35","_clearTimeout","timerId","delete","_setTimeout","_func","_this$nextTimer","_this$nextTimer2","_this6","func","paused","time","_forEachSubscriber","_iterator2","_step2","sub","subscriber","_getSubscriber","_recoverSubscriber","oldSub","newSub","_iterator3","_step3","started","_on","_callee31","_callee31$","_context31","_getSub2","listeners","on","_x36","_x37","_once","_callee32","_callee32$","_context32","_x38","_x39","_emit","_callee33","_this7","_len","args","_key","count","_args33","_callee33$","_context33","_hasSub2","_ref8","payload","_x40","_listenerCount","_callee34","total","_iterator4","_step4","_callee34$","_context34","listenerCount","_x41","_listeners","_callee35","_iterator5","_step5","_listeners2","_callee35$","_context35","_ref9","_ref10","_x42","_off","_callee36","_callee36$","_context36","_ref11","splice","_x43","_x44","_removeAllListeners","_callee37","_yield$_classPrivateM","_iterator6","_step6","_step6$value","_tag","_step6$value$","_started","_subscriber","_callee37$","_context37","removeAllListeners","_x45","_addListener","_callee38","_callee38$","_context38","addListener","_x46","_x47","_removeListener","_callee39","_callee39$","_context39","removeListener","_x48","_x49","destroy","_iterator7","_step7","_iterator8","_step8","_iterator9","_step9","_x50","_perform4","_callee42","_this8","perform","_callee42$","_context42","_x51","_x52","_x53","_call4","_callee43","attempt","txSender","ccipArgs","ccipResult","_tx2","_callee43$","_context43","t2","parseOffchainLookup","invocation","revert","signature","errorArgs","selector","encodeBytes","extraData","t3","_x54","_checkNetwork3","_callee44","promise","_yield$resolvePropert9","_callee44$","_context44","_x55","_x56","_x57","_getAccountValue3","_callee45","_blockTag","_yield$Promise$all3","_yield$Promise$all4","_callee45$","_context45","_x58","_x59","_getBlock4","_callee46","includeTransactions","_callee46$","_context46","_x60","_x61","_hasSub3","_callee47","emitArgs","_callee47$","_context47","removed","_x62","_getSub3","_callee48","subscription","addressableMap","nameMap","_callee48$","_context48","_parseString","bytes","_parseBytes","offset","numPad","padded","Uint8Array","bytesPad","Math","ceil","empty","datas","byteCount","zeros","urlsOffset","urlsLength","urlsData","u","split"],"sources":["C:\\Users\\prcue\\OneDrive\\Curso 4\\TFG GITT\\5. Desarrollo\\3. Frontend\\frontend_v3\\node_modules\\ethers\\src.ts\\providers\\abstract-provider.ts"],"sourcesContent":["/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport {\n    concat, dataLength, dataSlice, hexlify, isHexString,\n    getBigInt, getBytes, getNumber,\n    isCallException, isError, makeError, assert, assertArgument,\n    FetchRequest,\n    toBeArray, toQuantity,\n    defineProperties, EventPayload, resolveProperties,\n    toUtf8String\n} from \"../utils/index.js\";\n\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport {\n    formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse\n} from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport {\n    PollingBlockSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber\n} from \"./subscriber-polling.js\";\n\nimport type { Addressable, AddressLike } from \"../address/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\nimport type { Listener } from \"../utils/index.js\";\n\nimport type { Networkish } from \"./network.js\";\nimport type { FetchUrlFeeDataNetworkPlugin } from \"./plugins-network.js\";\n//import type { MaxPriorityFeePlugin } from \"./plugins-network.js\";\nimport type {\n    BlockParams, LogParams, TransactionReceiptParams,\n    TransactionResponseParams\n} from \"./formatting.js\";\n\nimport type {\n    BlockTag, EventFilter, Filter, FilterByBlockHash, OrphanFilter,\n    PreparedTransactionRequest, Provider, ProviderEvent,\n    TransactionRequest\n} from \"./provider.js\";\n\ntype Timer = ReturnType<typeof setTimeout>;\n\n\n// Constants\nconst BN_2 = BigInt(2);\n\nconst MAX_CCIP_REDIRECTS = 10;\n\nfunction isPromise<T = any>(value: any): value is Promise<T> {\n    return (value && typeof(value.then) === \"function\");\n}\n\nfunction getTag(prefix: string, value: any): string {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) { return \"null\"; }\n        if (typeof(v) === \"bigint\") { return `bigint:${ v.toString() }`}\n        if (typeof(v) === \"string\") { return v.toLowerCase(); }\n\n        // Sort object keys\n        if (typeof(v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, <any>{ });\n        }\n\n        return v;\n    });\n}\n\n/**\n *  The types of additional event values that can be emitted for the\n *  ``\"debug\"`` event.\n */\nexport type DebugEventAbstractProvider = {\n    action: \"sendCcipReadFetchRequest\",\n    request: FetchRequest\n    index: number\n    urls: Array<string>\n} | {\n    action: \"receiveCcipReadFetchResult\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"receiveCcipReadFetchError\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"sendCcipReadCall\",\n    transaction: { to: string, data: string }\n} | {\n    action: \"receiveCcipReadCallResult\",\n    transaction: { to: string, data: string }\n    result: string\n} | {\n    action: \"receiveCcipReadCallError\",\n    transaction: { to: string, data: string }\n    error: Error\n};\n\n\n/**\n *  The value passed to the [[AbstractProvider-_getSubscriber]] method.\n *\n *  Only developers sub-classing [[AbstractProvider[[ will care about this,\n *  if they are modifying a low-level feature of how subscriptions operate.\n */\nexport type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"error\" | \"network\" | \"pending\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n    tag: string,\n    filter: OrphanFilter\n};\n\n/**\n *  A **Subscriber** manages a subscription.\n *\n *  Only developers sub-classing [[AbstractProvider[[ will care about this,\n *  if they are modifying a low-level feature of how subscriptions operate.\n */\nexport interface Subscriber {\n    /**\n     *  Called initially when a subscriber is added the first time.\n     */\n    start(): void;\n\n    /**\n     *  Called when there are no more subscribers to the event.\n     */\n    stop(): void;\n\n    /**\n     *  Called when the subscription should pause.\n     *\n     *  If %%dropWhilePaused%%, events that occur while paused should not\n     *  be emitted [[resume]].\n     */\n    pause(dropWhilePaused?: boolean): void;\n\n    /**\n     *  Resume a paused subscriber.\n     */\n    resume(): void;\n\n    /**\n     *  The frequency (in ms) to poll for events, if polling is used by\n     *  the subscriber.\n     *\n     *  For non-polling subscribers, this must return ``undefined``.\n     */\n    pollingInterval?: number;\n}\n\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport class UnmanagedSubscriber implements Subscriber {\n    /**\n     *  The name fof the event.\n     */\n    name!: string;\n\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): void { }\n    stop(): void { }\n\n    pause(dropWhilePaused?: boolean): void { }\n    resume(): void { }\n}\n\ntype Sub = {\n    tag: string;\n    nameMap: Map<string, string>\n    addressableMap: WeakMap<Addressable, string>;\n    listeners: Array<{ listener: Listener, once: boolean }>;\n    // @TODO: get rid of this, as it is (and has to be)\n    // tracked in subscriber\n    started: boolean;\n    subscriber: Subscriber;\n};\n\nfunction copy<T = any>(value: T): T {\n    return JSON.parse(JSON.stringify(value));\n}\n\nfunction concisify(items: Array<string>): Array<string> {\n    items = Array.from((new Set(items)).values())\n    items.sort();\n    return items;\n}\n\n\nasync function getSubscription(_event: ProviderEvent, provider: AbstractProvider): Promise<Subscription> {\n    if (_event == null) { throw new Error(\"invalid event\"); }\n\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) { _event = { topics: _event }; }\n\n    if (typeof(_event) === \"string\") {\n        switch (_event) {\n            case \"block\": case \"pending\": case \"debug\": case \"error\": case \"network\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n\n    if (isHexString(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n\n    if ((<any>_event).orphan) {\n        const event = <OrphanFilter>_event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n\n    if (((<any>_event).address || (<any>_event).topics)) {\n        const event = <EventFilter>_event;\n\n        const filter: any = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) { return null; }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n\n        if (event.address) {\n            const addresses: Array<string> = [ ];\n            const promises: Array<Promise<void>> = [ ];\n\n            const addAddress = (addr: AddressLike) => {\n                if (isHexString(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async () => {\n                        addresses.push(await resolveAddress(addr, provider));\n                    })());\n                }\n            }\n\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) { await Promise.all(promises); }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n\n    assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\n/**\n *  An **AbstractPlugin** is used to provide additional internal services\n *  to an [[AbstractProvider]] without adding backwards-incompatible changes\n *  to method signatures or other internal and complex logic.\n */\nexport interface AbstractProviderPlugin {\n    /**\n     *  The reverse domain notation of the plugin.\n     */\n    readonly name: string;\n\n    /**\n     *  Creates a new instance of the plugin, connected to %%provider%%.\n     */\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}\n\n/**\n *  A normalized filter used for [[PerformActionRequest]] objects.\n */\nexport type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};\n\n/**\n *  A normalized transactions used for [[PerformActionRequest]] objects.\n */\nexport interface PerformActionTransaction extends PreparedTransactionRequest {\n    /**\n     *  The ``to`` address of the transaction.\n     */\n    to?: string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: string;\n}\n\n/**\n *  The [[AbstractProvider]] methods will normalize all values and pass this\n *  type to [[AbstractProvider-_perform]].\n */\nexport type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n    method: \"getBalance\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getBlock\",\n    blockTag: BlockTag, includeTransactions: boolean\n} | {\n    method: \"getBlock\",\n    blockHash: string, includeTransactions: boolean\n} | {\n    method: \"getBlockNumber\"\n} | {\n    method: \"getCode\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getGasPrice\"\n} | {\n    method: \"getLogs\",\n    filter: PerformActionFilter\n} | {\n    method: \"getStorage\",\n    address: string, position: bigint, blockTag: BlockTag\n} | {\n    method: \"getTransaction\",\n    hash: string\n} | {\n    method: \"getTransactionCount\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getTransactionReceipt\",\n    hash: string\n} | {\n    method: \"getTransactionResult\",\n    hash: string\n};\n\ntype _PerformAccountRequest = {\n    method: \"getBalance\" | \"getTransactionCount\" | \"getCode\"\n} | {\n    method: \"getStorage\", position: bigint\n}\n\n/**\n *  Options for configuring some internal aspects of an [[AbstractProvider]].\n *\n *  **``cacheTimeout``** - how long to cache a low-level ``_perform``\n *  for, based on input parameters. This reduces the number of calls\n *  to getChainId and getBlockNumber, but may break test chains which\n *  can perform operations (internally) synchronously. Use ``-1`` to\n *  disable, ``0`` will only buffer within the same event loop and\n *  any other value is in ms. (default: ``250``)\n */\nexport type AbstractProviderOptions = {\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};\n\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n\ntype CcipArgs = {\n    sender: string;\n    urls: Array<string>;\n    calldata: string;\n    selector: string;\n    extraData: string;\n    errorArgs: Array<any>\n};\n\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nexport class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #destroyed: boolean;\n\n    #networkPromise: null | Promise<Network>;\n    readonly #anyNetwork: boolean;\n\n    #performCache: Map<string, Promise<any>>;\n\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber: number;\n\n    #nextTimer: number;\n    #timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;\n\n    #disableCcipRead: boolean;\n\n    #options: Required<AbstractProviderOptions>;\n\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */\n    constructor(_network?: \"any\" | Networkish, options?: AbstractProviderOptions) {\n        this.#options = Object.assign({ }, defaultOptions, options || { });\n\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n\n        this.#lastBlockNumber = -1;\n\n        this.#performCache = new Map();\n\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n\n        this.#destroyed = false;\n\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n\n        this.#disableCcipRead = false;\n    }\n\n    get pollingInterval(): number { return this.#options.pollingInterval; }\n\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n    get provider(): this { return this; }\n\n    /**\n     *  Returns all the registered plug-ins.\n     */\n    get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }\n\n    /**\n     *  Attach a new plug-in.\n     */\n    attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }\n\n    /**\n     *  Get a plugin by name.\n     */\n    getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }\n\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n    get disableCcipRead(): boolean { return this.#disableCcipRead; }\n    set disableCcipRead(value: boolean) { this.#disableCcipRead = !!value; }\n\n    // Shares multiple identical requests made during the same 250ms\n    async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        const timeout = this.#options.cacheTimeout;\n\n        // Caching disabled\n        if (timeout < 0) { return await this._perform(req); }\n\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n\n            this.#performCache.set(tag, perform);\n\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n\n        return await perform;\n    }\n\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n\n            let errorMessage = \"unknown error\";\n\n            const resp = await request.send();\n            try {\n                 const result = resp.bodyJson;\n                 if (result.data) {\n                     this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                     return result.data;\n                 }\n                 if (result.message) { errorMessage = result.message; }\n                 this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            } catch (error) { }\n\n            // 4xx indicates the result is not present; stop\n            assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${ errorMessage }`,\n                \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        assert(false, `error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n    _wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n    _wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n    _wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n    _wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }\n\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n    _detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n    async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n\n    // State\n\n    async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }\n\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n    _getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }\n\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n    _getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\": case \"pending\": case \"safe\": case \"finalized\":\n                return blockTag;\n        }\n\n\n        if (isHexString(blockTag)) {\n            if (isHexString(blockTag, 32)) { return blockTag; }\n            return toQuantity(blockTag);\n        }\n\n        if (typeof(blockTag) === \"bigint\") {\n            blockTag = getNumber(blockTag, \"blockTag\");\n        }\n\n        if (typeof(blockTag) === \"number\") {\n            if (blockTag >= 0) { return toQuantity(blockTag); }\n            if (this.#lastBlockNumber >= 0) { return toQuantity(this.#lastBlockNumber + blockTag); }\n            return this.getBlockNumber().then((b) => toQuantity(b + <number>blockTag));\n        }\n\n        assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n    _getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash: undefined;\n\n        const resolve = (_address: Array<string>, fromBlock?: string, toBlock?: string) => {\n            let address: undefined | string | Array<string> = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n\n            const filter = <any>{ };\n            if (address) { filter.address = address; }\n            if (topics.length) { filter.topics = topics; }\n            if (fromBlock) { filter.fromBlock = fromBlock; }\n            if (toBlock) { filter.toBlock = toBlock; }\n            if (blockHash) { filter.blockHash = blockHash; }\n\n            return filter;\n        };\n\n        // Addresses could be async (ENS names or Addressables)\n        let address: Array<string | Promise<string>> = [ ];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) { address.push(this._getAddress(addr)); }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n\n        let fromBlock: undefined | string | Promise<string> = undefined;\n        if (\"fromBlock\" in filter) { fromBlock = this._getBlockTag(filter.fromBlock); }\n\n        let toBlock: undefined | string | Promise<string> = undefined;\n        if (\"toBlock\" in filter) { toBlock = this._getBlockTag(filter.toBlock); }\n\n        if (address.filter((a) => (typeof(a) !== \"string\")).length ||\n            (fromBlock != null && typeof(fromBlock) !== \"string\") ||\n            (toBlock != null && typeof(toBlock) !== \"string\")) {\n\n            return Promise.all([ Promise.all(address), fromBlock, toBlock ]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n\n        return resolve(<Array<string>>address, fromBlock, toBlock);\n    }\n\n    /**\n     *  Returns or resovles to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n    _getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            if ((<any>request)[key] == null) { return; }\n\n            const addr = resolveAddress((<any>request)[key]);\n            if (isPromise(addr)) {\n                promises.push((async function() { (<any>request)[key] = await addr; })());\n            } else {\n                (<any>request)[key] = addr;\n            }\n        });\n\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function() { request.blockTag = await blockTag; })());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n\n        if (promises.length) {\n            return (async function() {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n\n        return request;\n    }\n\n    async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = this._detectNetwork().then((network) => {\n                this.emit(\"network\", network, null);\n                return network;\n            }, (error) => {\n                // Reset the networkPromise on failure, so we will try again\n                if (this.#networkPromise === detectNetwork) {\n                    this.#networkPromise = null;\n                }\n                throw error;\n            });\n\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n\n        const networkPromise = this.#networkPromise;\n\n        const [ expected, actual ] = await Promise.all([\n            networkPromise,          // Possibly an explicit Network\n            this._detectNetwork()    // The actual connected network\n        ]);\n\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                assert(false, `network changed: ${ expected.chainId } => ${ actual.chainId } `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n\n        return expected.clone();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        const network = await this.getNetwork();\n\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((async () => {\n                    try {\n                        const gasPrice = await this.#perform({ method: \"getGasPrice\" });\n                        return getBigInt(gasPrice, \"%response\");\n                    } catch (error) { }\n                    return null\n                })())\n            });\n\n            let maxFeePerGas: null | bigint = null;\n            let maxPriorityFeePerGas: null | bigint = null;\n\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = BigInt(\"1000000000\");\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n            }\n\n            return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = <FetchUrlFeeDataNetworkPlugin>network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n\n        return await getFeeDataFunc();\n    }\n\n\n    async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n\n    async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { blockTag, enableCcipRead: true })\n         });\n\n         // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n         const transaction = <PerformActionTransaction>copyRequest(tx);\n\n         try {\n             return hexlify(await this._perform({ method: \"call\", transaction, blockTag }));\n\n         } catch (error: any) {\n             // CCIP Read OffchainLookup\n             if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n                 const data = error.data;\n\n                 const txSender = await resolveAddress(transaction.to, this);\n\n                 // Parse the CCIP Read Arguments\n                 let ccipArgs: CcipArgs;\n                 try {\n                     ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n                 } catch (error: any) {\n                     assert(false, error.message, \"OFFCHAIN_FAULT\", {\n                         reason: \"BAD_DATA\", transaction, info: { data } });\n                 }\n\n                 // Check the sender of the OffchainLookup matches the transaction\n                 assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(),\n                     \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                         action: \"call\",\n                         data,\n                         reason: \"OffchainLookup\",\n                         transaction: <any>transaction, // @TODO: populate data?\n                         invocation: null,\n                         revert: {\n                             signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                             name: \"OffchainLookup\",\n                             args: ccipArgs.errorArgs\n                         }\n                     });\n\n                 const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                 assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                     reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs } });\n\n                 const tx = {\n                     to: txSender,\n                     data: concat([ ccipArgs.selector, encodeBytes([ ccipResult, ccipArgs.extraData ]) ])\n                 };\n\n                 this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                 try {\n                     const result = await this.#call(tx, blockTag, attempt + 1);\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({ }, tx), result });\n                     return result;\n                 } catch (error) {\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({ }, tx), error });\n                     throw error;\n                 }\n             }\n\n             throw error;\n         }\n    }\n\n    async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n\n    async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0: -1));\n    }\n\n    // Account\n    async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address) !== \"string\" || typeof(blockTag) !== \"string\") {\n            [ address, blockTag ] = await Promise.all([ address, blockTag ]);\n        }\n\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n\n    async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n\n    async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n\n    async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n\n    async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n\n    // Write\n    async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 signedTransaction: signedTx\n             }),\n             network: this.getNetwork()\n        });\n\n        const tx = Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n\n        return this._wrapTransactionResponse(<any>tx, network).replaceableTransaction(blockNumber);\n    }\n\n    async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n\n        let blockTag = this._getBlockTag(block);\n        if (typeof(blockTag) !== \"string\") { blockTag = await blockTag; }\n\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n\n    // Queries\n    async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return null; }\n\n        return this._wrapBlock(params, network);\n    }\n\n    async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null; }\n\n        return this._wrapTransactionResponse(params, network);\n    }\n\n    async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) { return null; }\n\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) { throw new Error(\"report this; could not find tx or effectiveGasPrice\"); }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n\n        return this._wrapTransactionReceipt(params, network);\n    }\n\n    async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n        return hexlify(result);\n    }\n\n    // Bloom-filter Queries\n    async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform<Array<LogParams>>({ method: \"getLogs\", filter })\n        });\n\n        return params.map((p) => this._wrapLog(p, network));\n    }\n\n    // ENS\n    _getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n\n    async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }\n\n    async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }\n\n    async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }\n\n    async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === ZeroAddress) { return null; }\n\n            const resolverContract = new Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) { return null; }\n\n            return name;\n\n        } catch (error) {\n            // No data was returned from the resolver\n            if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n\n            // Something reerted\n            if (isError(error, \"CALL_EXCEPTION\")) { return null; }\n\n            throw error;\n        }\n\n        return null;\n    }\n\n    async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (resolve, reject) => {\n            let timer: null | Timer = null;\n\n            const listener = (async (blockNumber: number) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject(makeError(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n\n            listener(await this.getBlockNumber());\n        });\n    }\n\n    async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n    _clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }\n\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n    _setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n\n        return timerId;\n    }\n\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n    _forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n    _getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscriber(this);\n                subscriber.pollingInterval = this.pollingInterval;\n                return subscriber;\n            }\n            case \"event\":\n                return new PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new PollingOrphanSubscriber(this, sub.filter);\n        }\n\n        throw new Error(`unsupported event: ${ sub.type }`);\n    }\n\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n    _recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { newSub.start(); }\n                if (this.#pausedState != null) { newSub.pause(this.#pausedState); }\n                break;\n            }\n        }\n    }\n\n    async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n\n    async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [ ] };\n            this.#subs.set(tag, sub);\n        }\n\n        return sub;\n    }\n\n    async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) { return false; };\n\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new EventPayload(this, (once ? null: listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch(error) { }\n            return !once;\n        });\n\n        if (sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return (count > 0);\n    }\n\n    async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { started, subscriber } ] of this.#subs) {\n                if (started) { subscriber.stop(); }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n\n    // Alias for \"on\"\n    async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }\n\n    // Alias for \"off\"\n    async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }\n\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n    get destroyed(): boolean {\n        return this.#destroyed;\n    }\n\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n    destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n\n        this.#destroyed = true;\n    }\n\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n    get paused(): boolean { return (this.#pausedState != null); }\n    set paused(pause: boolean) {\n        if (!!pause === this.paused) { return; }\n\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n    pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) { clearTimeout(timer.timer); }\n\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n\n    /**\n     *  Resume the provider.\n     */\n    resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) { timeout = 0; }\n\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\n\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) { return toUtf8String(bytes); }\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n    try {\n        const offset = getNumber(dataSlice(result, start, start + 32));\n        const length = getNumber(dataSlice(result, offset, offset + 32));\n\n        return dataSlice(result, offset + 32, offset + 32 + length);\n    } catch (error) { }\n    return null;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = toBeArray(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\nconst empty: Uint8Array = new Uint8Array([ ]);\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>): string {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = getBytes(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return concat(result);\n}\n\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\"\nfunction parseOffchainLookup(data: string): CcipArgs {\n    const result: CcipArgs = {\n        sender: \"\", urls: [ ], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: [ ]\n    };\n\n    assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n\n    const sender = dataSlice(data, 0, 32);\n    assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = dataSlice(sender, 12);\n\n    // Read the URLs from the response\n    try {\n        const urls: Array<string> = [];\n        const urlsOffset = getNumber(dataSlice(data, 32, 64));\n        const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n        const urlsData = dataSlice(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) { throw new Error(\"abort\"); }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) { throw new Error(\"abort\"); }\n        result.calldata = calldata;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n\n    // Get the callbackSelector (bytes4)\n    assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = dataSlice(data, 96, 100);\n\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) { throw new Error(\"abort\"); }\n        result.extraData = extraData;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => (<any>result)[k])\n\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}