{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _get from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _assertThisInitialized from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\n/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]\n */\nimport { UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { assert, assertArgument, makeError } from \"../utils/index.js\";\nimport { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _filter = /*#__PURE__*/new WeakMap();\nvar _filterId = /*#__PURE__*/new WeakMap();\nvar _paused = /*#__PURE__*/new WeakMap();\nvar _emitPromise = /*#__PURE__*/new WeakMap();\nexport var SocketSubscriber = /*#__PURE__*/function () {\n  /**\n   *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n   *  to %%filter%%.\n   */\n  function SocketSubscriber(provider, filter) {\n    _classCallCheck(this, SocketSubscriber);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filterId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _paused, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _emitPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider, provider);\n    _classPrivateFieldSet(this, _filter, JSON.stringify(filter));\n    _classPrivateFieldSet(this, _filterId, null);\n    _classPrivateFieldSet(this, _paused, null);\n    _classPrivateFieldSet(this, _emitPromise, null);\n  }\n  _createClass(SocketSubscriber, [{\n    key: \"filter\",\n    get:\n    /**\n     *  The filter.\n     */\n    function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _filter));\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n      _classPrivateFieldSet(this, _filterId, _classPrivateFieldGet(this, _provider).send(\"eth_subscribe\", this.filter).then(function (filterId) {\n        ;\n        _classPrivateFieldGet(_this, _provider)._register(filterId, _this);\n        return filterId;\n      }));\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this2 = this;\n      _classPrivateFieldGet(this, _filterId).then(function (filterId) {\n        _classPrivateFieldGet(_this2, _provider).send(\"eth_unsubscribe\", [filterId]);\n      });\n      _classPrivateFieldSet(this, _filterId, null);\n    }\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n  }, {\n    key: \"pause\",\n    value: function pause(dropWhilePaused) {\n      assert(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"pause(false)\"\n      });\n      _classPrivateFieldSet(this, _paused, !!dropWhilePaused);\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      _classPrivateFieldSet(this, _paused, null);\n    }\n    /**\n     *  @_ignore:\n     */\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(message) {\n      var _this3 = this;\n      if (_classPrivateFieldGet(this, _filterId) == null) {\n        return;\n      }\n      if (_classPrivateFieldGet(this, _paused) === null) {\n        var emitPromise = _classPrivateFieldGet(this, _emitPromise);\n        if (emitPromise == null) {\n          emitPromise = this._emit(_classPrivateFieldGet(this, _provider), message);\n        } else {\n          emitPromise = emitPromise.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return _this3._emit(_classPrivateFieldGet(_this3, _provider), message);\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          })));\n        }\n        _classPrivateFieldSet(this, _emitPromise, emitPromise.then(function () {\n          if (_classPrivateFieldGet(_this3, _emitPromise) === emitPromise) {\n            _classPrivateFieldSet(_this3, _emitPromise, null);\n          }\n        }));\n      }\n    }\n    /**\n     *  Sub-classes **must** override this to emit the events on the\n     *  provider.\n     */\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new Error(\"sub-classes must implemente this; _emit\");\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function _emit(_x, _x2) {\n        return _emit2.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketSubscriber;\n}();\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */\nexport var SocketBlockSubscriber = /*#__PURE__*/function (_SocketSubscriber) {\n  _inherits(SocketBlockSubscriber, _SocketSubscriber);\n  var _super = _createSuper(SocketBlockSubscriber);\n  /**\n   *  @_ignore:\n   */\n  function SocketBlockSubscriber(provider) {\n    _classCallCheck(this, SocketBlockSubscriber);\n    return _super.call(this, provider, [\"newHeads\"]);\n  }\n  _createClass(SocketBlockSubscriber, [{\n    key: \"_emit\",\n    value: function () {\n      var _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              provider.emit(\"block\", parseInt(message.number));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function _emit(_x3, _x4) {\n        return _emit3.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketBlockSubscriber;\n}(SocketSubscriber);\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */\nexport var SocketPendingSubscriber = /*#__PURE__*/function (_SocketSubscriber2) {\n  _inherits(SocketPendingSubscriber, _SocketSubscriber2);\n  var _super2 = _createSuper(SocketPendingSubscriber);\n  /**\n   *  @_ignore:\n   */\n  function SocketPendingSubscriber(provider) {\n    _classCallCheck(this, SocketPendingSubscriber);\n    return _super2.call(this, provider, [\"newPendingTransactions\"]);\n  }\n  _createClass(SocketPendingSubscriber, [{\n    key: \"_emit\",\n    value: function () {\n      var _emit4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              provider.emit(\"pending\", message);\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function _emit(_x5, _x6) {\n        return _emit4.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketPendingSubscriber;\n}(SocketSubscriber);\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */\nvar _logFilter = /*#__PURE__*/new WeakMap();\nexport var SocketEventSubscriber = /*#__PURE__*/function (_SocketSubscriber3) {\n  _inherits(SocketEventSubscriber, _SocketSubscriber3);\n  var _super3 = _createSuper(SocketEventSubscriber);\n  /**\n   *  @_ignore:\n   */\n  function SocketEventSubscriber(provider, filter) {\n    var _this4;\n    _classCallCheck(this, SocketEventSubscriber);\n    _this4 = _super3.call(this, provider, [\"logs\", filter]);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _logFilter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _logFilter, JSON.stringify(filter));\n    return _this4;\n  }\n  _createClass(SocketEventSubscriber, [{\n    key: \"logFilter\",\n    get:\n    /**\n     *  The filter.\n     */\n    function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _logFilter));\n    }\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _emit(_x7, _x8) {\n        return _emit5.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketEventSubscriber;\n}(SocketSubscriber);\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */\nvar _callbacks = /*#__PURE__*/new WeakMap();\nvar _subs = /*#__PURE__*/new WeakMap();\nvar _pending = /*#__PURE__*/new WeakMap();\nexport var SocketProvider = /*#__PURE__*/function (_JsonRpcApiProvider) {\n  _inherits(SocketProvider, _JsonRpcApiProvider);\n  var _super4 = _createSuper(SocketProvider);\n  /**\n   *  Creates a new **SocketProvider** connected to %%network%%.\n   *\n   *  If unspecified, the network will be discovered.\n   */\n  function SocketProvider(network) {\n    var _this5;\n    _classCallCheck(this, SocketProvider);\n    _this5 = _super4.call(this, network, {\n      batchMaxCount: 1\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _callbacks, {\n      writable: true,\n      value: void 0\n    });\n    // Maps each filterId to its subscriber\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _subs, {\n      writable: true,\n      value: void 0\n    });\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _pending, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _callbacks, new Map());\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _subs, new Map());\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _pending, new Map());\n    return _this5;\n  }\n  // This value is only valid after _start has been called\n  /*\n  get _network(): Network {\n      if (this.#network == null) {\n          throw new Error(\"this shouldn't happen\");\n      }\n      return this.#network.clone();\n  }\n  */\n  _createClass(SocketProvider, [{\n    key: \"_getSubscriber\",\n    value: function _getSubscriber(sub) {\n      switch (sub.type) {\n        case \"close\":\n          return new UnmanagedSubscriber(\"close\");\n        case \"block\":\n          return new SocketBlockSubscriber(this);\n        case \"pending\":\n          return new SocketPendingSubscriber(this);\n        case \"event\":\n          return new SocketEventSubscriber(this, sub.filter);\n        case \"orphan\":\n          // Handled auto-matically within AbstractProvider\n          // when the log.removed = true\n          if (sub.filter.orphan === \"drop-log\") {\n            return new UnmanagedSubscriber(\"drop-log\");\n          }\n      }\n      return _get(_getPrototypeOf(SocketProvider.prototype), \"_getSubscriber\", this).call(this, sub);\n    }\n    /**\n     *  Register a new subscriber. This is used internalled by Subscribers\n     *  and generally is unecessary unless extending capabilities.\n     */\n  }, {\n    key: \"_register\",\n    value: function _register(filterId, subscriber) {\n      _classPrivateFieldGet(this, _subs).set(filterId, subscriber);\n      var pending = _classPrivateFieldGet(this, _pending).get(filterId);\n      if (pending) {\n        var _iterator = _createForOfIteratorHelper(pending),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var message = _step.value;\n            subscriber._handleMessage(message);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        _classPrivateFieldGet(this, _pending).delete(filterId);\n      }\n    }\n  }, {\n    key: \"_send\",\n    value: function () {\n      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(payload) {\n        var _this6 = this;\n        var promise;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              // WebSocket provider doesn't accept batches\n              assertArgument(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n              // @TODO: stringify payloads here and store to prevent mutations\n              // Prepare a promise to respond to\n              promise = new Promise(function (resolve, reject) {\n                _classPrivateFieldGet(_this6, _callbacks).set(payload.id, {\n                  payload: payload,\n                  resolve: resolve,\n                  reject: reject\n                });\n              }); // Wait until the socket is connected before writing to it\n              _context6.next = 4;\n              return this._waitUntilReady();\n            case 4:\n              _context6.next = 6;\n              return this._write(JSON.stringify(payload));\n            case 6:\n              _context6.next = 8;\n              return promise;\n            case 8:\n              _context6.t0 = _context6.sent;\n              return _context6.abrupt(\"return\", [_context6.t0]);\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function _send(_x9) {\n        return _send2.apply(this, arguments);\n      }\n      return _send;\n    }() // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n         for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n         this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n    /**\n     *  Sub-classes **must** call this with messages received over their\n     *  transport to be processed and dispatched.\n     */\n  }, {\n    key: \"_processMessage\",\n    value: function () {\n      var _processMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message) {\n        var result, callback, filterId, subscriber, pending;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              result = JSON.parse(message);\n              if (!(result && typeof result === \"object\" && \"id\" in result)) {\n                _context7.next = 10;\n                break;\n              }\n              callback = _classPrivateFieldGet(this, _callbacks).get(result.id);\n              if (!(callback == null)) {\n                _context7.next = 6;\n                break;\n              }\n              this.emit(\"error\", makeError(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNKNOWN_ID\",\n                result: result\n              }));\n              return _context7.abrupt(\"return\");\n            case 6:\n              _classPrivateFieldGet(this, _callbacks).delete(result.id);\n              callback.resolve(result);\n              _context7.next = 18;\n              break;\n            case 10:\n              if (!(result && result.method === \"eth_subscription\")) {\n                _context7.next = 16;\n                break;\n              }\n              filterId = result.params.subscription;\n              subscriber = _classPrivateFieldGet(this, _subs).get(filterId);\n              if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n              } else {\n                pending = _classPrivateFieldGet(this, _pending).get(filterId);\n                if (pending == null) {\n                  pending = [];\n                  _classPrivateFieldGet(this, _pending).set(filterId, pending);\n                }\n                pending.push(result.params.result);\n              }\n              _context7.next = 18;\n              break;\n            case 16:\n              this.emit(\"error\", makeError(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNEXPECTED_MESSAGE\",\n                result: result\n              }));\n              return _context7.abrupt(\"return\");\n            case 18:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function _processMessage(_x10) {\n        return _processMessage2.apply(this, arguments);\n      }\n      return _processMessage;\n    }()\n    /**\n     *  Sub-classes **must** override this to send %%message%% over their\n     *  transport.\n     */\n  }, {\n    key: \"_write\",\n    value: function () {\n      var _write2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(message) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              throw new Error(\"sub-classes must override this\");\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8);\n      }));\n      function _write(_x11) {\n        return _write2.apply(this, arguments);\n      }\n      return _write;\n    }()\n  }]);\n  return SocketProvider;\n}(JsonRpcApiProvider);","map":{"version":3,"names":["UnmanagedSubscriber","assert","assertArgument","makeError","JsonRpcApiProvider","_provider","WeakMap","_filter","_filterId","_paused","_emitPromise","SocketSubscriber","provider","filter","_classCallCheck","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","JSON","stringify","_createClass","key","get","parse","_classPrivateFieldGet","start","_this","send","then","filterId","_register","stop","_this2","pause","dropWhilePaused","operation","resume","_handleMessage","message","_this3","emitPromise","_emit","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","_emit2","_callee2","_callee2$","_context2","Error","_x","_x2","apply","arguments","SocketBlockSubscriber","_SocketSubscriber","_inherits","_super","_createSuper","call","_emit3","_callee3","_callee3$","_context3","emit","parseInt","number","_x3","_x4","SocketPendingSubscriber","_SocketSubscriber2","_super2","_emit4","_callee4","_callee4$","_context4","_x5","_x6","_logFilter","SocketEventSubscriber","_SocketSubscriber3","_super3","_this4","_assertThisInitialized","_emit5","_callee5","_callee5$","_context5","logFilter","_wrapLog","_network","_x7","_x8","_callbacks","_subs","_pending","SocketProvider","_JsonRpcApiProvider","_super4","network","_this5","batchMaxCount","Map","_getSubscriber","sub","type","orphan","_get","_getPrototypeOf","prototype","subscriber","set","pending","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","delete","_send2","_callee6","payload","_this6","promise","_callee6$","_context6","Array","isArray","Promise","resolve","reject","id","_waitUntilReady","_write","t0","sent","abrupt","_send","_x9","_processMessage2","_callee7","result","callback","_callee7$","_context7","reasonCode","method","params","subscription","push","_processMessage","_x10","_write2","_callee8","_callee8$","_context8","_x11"],"sources":["C:\\Users\\prcue\\OneDrive\\Curso 4\\TFG GITT\\5. Desarrollo\\3. Frontend\\frontend_v3\\node_modules\\ethers\\src.ts\\providers\\provider-socket.ts"],"sourcesContent":["/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]\n */\n\nimport { UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { assert, assertArgument, makeError } from \"../utils/index.js\";\nimport { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n\nimport type { Subscriber, Subscription } from \"./abstract-provider.js\";\nimport type { EventFilter } from \"./provider.js\";\nimport type { JsonRpcError, JsonRpcPayload, JsonRpcResult } from \"./provider-jsonrpc.js\";\nimport type { Networkish } from \"./network.js\";\n\n\ntype JsonRpcSubscription = {\n    method: string,\n    params: {\n        result: any,\n        subscription: string\n    }\n};\n\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */\nexport class SocketSubscriber implements Subscriber {\n    #provider: SocketProvider;\n\n    #filter: string;\n\n    /**\n     *  The filter.\n     */\n    get filter(): Array<any> { return JSON.parse(this.#filter); }\n\n    #filterId: null | Promise<string |number>;\n    #paused: null | boolean;\n\n    #emitPromise: null | Promise<void>;\n\n    /**\n     *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n     *  to %%filter%%.\n     */\n    constructor(provider: SocketProvider, filter: Array<any>) {\n        this.#provider = provider;\n        this.#filter = JSON.stringify(filter);\n        this.#filterId = null;\n        this.#paused = null;\n        this.#emitPromise = null;\n    }\n\n    start(): void {\n        this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then((filterId) => {;\n            this.#provider._register(filterId, this);\n            return filterId;\n        });\n    }\n\n    stop(): void {\n        (<Promise<number>>(this.#filterId)).then((filterId) => {\n            this.#provider.send(\"eth_unsubscribe\", [ filterId ]);\n        });\n        this.#filterId = null;\n    }\n\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n    pause(dropWhilePaused?: boolean): void {\n        assert(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"pause(false)\" });\n        this.#paused = !!dropWhilePaused;\n    }\n\n    resume(): void {\n        this.#paused = null;\n    }\n\n    /**\n     *  @_ignore:\n     */\n    _handleMessage(message: any): void {\n        if (this.#filterId == null) { return; }\n        if (this.#paused === null) {\n            let emitPromise: null | Promise<void> = this.#emitPromise;\n            if (emitPromise == null) {\n                emitPromise = this._emit(this.#provider, message);\n            } else {\n                emitPromise = emitPromise.then(async () => {\n                    await this._emit(this.#provider, message);\n                });\n            }\n            this.#emitPromise = emitPromise.then(() => {\n                if (this.#emitPromise === emitPromise) {\n                    this.#emitPromise = null;\n                }\n            });\n        }\n    }\n\n    /**\n     *  Sub-classes **must** override this to emit the events on the\n     *  provider.\n     */\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        throw new Error(\"sub-classes must implemente this; _emit\");\n    }\n}\n\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */\nexport class SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newHeads\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"block\", parseInt(message.number));\n    }\n}\n\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */\nexport class SocketPendingSubscriber extends SocketSubscriber {\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newPendingTransactions\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"pending\", message);\n    }\n}\n\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */\nexport class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter: string;\n\n    /**\n     *  The filter.\n     */\n    get logFilter(): EventFilter { return JSON.parse(this.#logFilter); }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(provider: SocketProvider, filter: EventFilter) {\n        super(provider, [ \"logs\", filter ]);\n        this.#logFilter = JSON.stringify(filter);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n    }\n}\n\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */\nexport class SocketProvider extends JsonRpcApiProvider {\n    #callbacks: Map<number, { payload: JsonRpcPayload, resolve: (r: any) => void, reject: (e: Error) => void }>;\n\n    // Maps each filterId to its subscriber\n    #subs: Map<number | string, SocketSubscriber>;\n\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    #pending: Map<number | string, Array<any>>;\n\n    /**\n     *  Creates a new **SocketProvider** connected to %%network%%.\n     *\n     *  If unspecified, the network will be discovered.\n     */\n    constructor(network?: Networkish) {\n        super(network, { batchMaxCount: 1 });\n        this.#callbacks = new Map();\n        this.#subs = new Map();\n        this.#pending = new Map();\n    }\n\n    // This value is only valid after _start has been called\n    /*\n    get _network(): Network {\n        if (this.#network == null) {\n            throw new Error(\"this shouldn't happen\");\n        }\n        return this.#network.clone();\n    }\n    */\n\n    _getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"close\":\n                return new UnmanagedSubscriber(\"close\");\n            case \"block\":\n                return new SocketBlockSubscriber(this);\n            case \"pending\":\n                return new SocketPendingSubscriber(this);\n            case \"event\":\n                return new SocketEventSubscriber(this, sub.filter);\n            case \"orphan\":\n                // Handled auto-matically within AbstractProvider\n                // when the log.removed = true\n                if (sub.filter.orphan === \"drop-log\") {\n                    return new UnmanagedSubscriber(\"drop-log\");\n                }\n        }\n        return super._getSubscriber(sub);\n    }\n\n    /**\n     *  Register a new subscriber. This is used internalled by Subscribers\n     *  and generally is unecessary unless extending capabilities.\n     */\n    _register(filterId: number | string, subscriber: SocketSubscriber): void {\n        this.#subs.set(filterId, subscriber);\n        const pending = this.#pending.get(filterId);\n        if (pending) {\n            for (const message of pending) {\n                subscriber._handleMessage(message);\n            }\n            this.#pending.delete(filterId);\n        }\n    }\n\n    async _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>> {\n        // WebSocket provider doesn't accept batches\n        assertArgument(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n\n        // @TODO: stringify payloads here and store to prevent mutations\n\n        // Prepare a promise to respond to\n        const promise = new Promise((resolve, reject) => {\n            this.#callbacks.set(payload.id, { payload, resolve, reject });\n        });\n\n        // Wait until the socket is connected before writing to it\n        await this._waitUntilReady();\n\n        // Write the request to the socket\n        await this._write(JSON.stringify(payload));\n\n        return <Array<JsonRpcResult | JsonRpcError>>[ await promise ];\n    }\n\n    // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n\n        for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n\n        this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n\n    /**\n     *  Sub-classes **must** call this with messages received over their\n     *  transport to be processed and dispatched.\n     */\n    async _processMessage(message: string): Promise<void> {\n        const result = <JsonRpcResult | JsonRpcError | JsonRpcSubscription>(JSON.parse(message));\n\n        if (result && typeof(result) === \"object\" && \"id\" in result) {\n            const callback = this.#callbacks.get(result.id);\n            if (callback == null) {\n                this.emit(\"error\", makeError(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n                    reasonCode: \"UNKNOWN_ID\",\n                    result\n                }));\n                return;\n            }\n            this.#callbacks.delete(result.id);\n\n            callback.resolve(result);\n\n        } else if (result && result.method === \"eth_subscription\") {\n            const filterId = result.params.subscription;\n            const subscriber = this.#subs.get(filterId);\n            if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n            } else {\n                let pending = this.#pending.get(filterId);\n                if (pending == null) {\n                    pending = [ ];\n                    this.#pending.set(filterId, pending);\n                }\n                pending.push(result.params.result);\n            }\n\n        } else {\n            this.emit(\"error\", makeError(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNEXPECTED_MESSAGE\",\n                result\n            }));\n            return;\n        }\n    }\n\n    /**\n     *  Sub-classes **must** override this to send %%message%% over their\n     *  transport.\n     */\n    async _write(message: string): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}