{"ast":null,"code":"import _inherits from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/prcue/OneDrive/Curso 4/TFG GITT/5. Desarrollo/3. Frontend/frontend_v3/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport { Interface, Typed } from \"../abi/index.js\";\nimport { isAddressable, resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log } from \"../providers/provider.js\";\nimport { defineProperties, getBigInt, isCallException, isHexString, resolveProperties, isError, makeError, assert, assertArgument } from \"../utils/index.js\";\nimport { ContractEventPayload, ContractUnknownEventPayload, ContractTransactionResponse, EventLog, UndecodedEventLog } from \"./wrappers.js\";\nvar BN_0 = BigInt(0);\nfunction canCall(value) {\n  return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n  return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n  return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n  return value && typeof value.sendTransaction === \"function\";\n}\nvar _filter = /*#__PURE__*/new WeakMap();\nvar PreparedTopicFilter = /*#__PURE__*/function () {\n  function PreparedTopicFilter(contract, fragment, args) {\n    _classCallCheck(this, PreparedTopicFilter);\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"fragment\", void 0);\n    defineProperties(this, {\n      fragment: fragment\n    });\n    if (fragment.inputs.length < args.length) {\n      throw new Error(\"too many arguments\");\n    }\n    // Recursively descend into args and resolve any addresses\n    var runner = getRunner(contract.runner, \"resolveName\");\n    var resolver = canResolve(runner) ? runner : null;\n    _classPrivateFieldSet(this, _filter, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var resolvedArgs;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.all(fragment.inputs.map(function (param, index) {\n              var arg = args[index];\n              if (arg == null) {\n                return null;\n              }\n              return param.walkAsync(args[index], function (type, value) {\n                if (type === \"address\") {\n                  if (Array.isArray(value)) {\n                    return Promise.all(value.map(function (v) {\n                      return resolveAddress(v, resolver);\n                    }));\n                  }\n                  return resolveAddress(value, resolver);\n                }\n                return value;\n              });\n            }));\n          case 2:\n            resolvedArgs = _context.sent;\n            return _context.abrupt(\"return\", contract.interface.encodeFilterTopics(fragment, resolvedArgs));\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))());\n  }\n  _createClass(PreparedTopicFilter, [{\n    key: \"getTopicFilter\",\n    value: function getTopicFilter() {\n      return _classPrivateFieldGet(this, _filter);\n    }\n  }]);\n  return PreparedTopicFilter;\n}(); // A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n  if (value == null) {\n    return null;\n  }\n  if (typeof value[feature] === \"function\") {\n    return value;\n  }\n  if (value.provider && typeof value.provider[feature] === \"function\") {\n    return value.provider;\n  }\n  return null;\n}\nfunction getProvider(value) {\n  if (value == null) {\n    return null;\n  }\n  return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nexport function copyOverrides(_x, _x2) {\n  return _copyOverrides.apply(this, arguments);\n}\n/**\n *  @_ignore:\n */\nfunction _copyOverrides() {\n  _copyOverrides = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(arg, allowed) {\n    var _overrides, overrides;\n    return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n      while (1) switch (_context28.prev = _context28.next) {\n        case 0:\n          // Make sure the overrides passed in are a valid overrides object\n          _overrides = Typed.dereference(arg, \"overrides\");\n          assertArgument(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n          // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n          overrides = copyRequest(_overrides);\n          assertArgument(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n          assertArgument(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n          // Resolve any from\n          if (!overrides.from) {\n            _context28.next = 9;\n            break;\n          }\n          _context28.next = 8;\n          return resolveAddress(overrides.from);\n        case 8:\n          overrides.from = _context28.sent;\n        case 9:\n          return _context28.abrupt(\"return\", overrides);\n        case 10:\n        case \"end\":\n          return _context28.stop();\n      }\n    }, _callee28);\n  }));\n  return _copyOverrides.apply(this, arguments);\n}\nexport function resolveArgs(_x3, _x4, _x5) {\n  return _resolveArgs.apply(this, arguments);\n}\nfunction _resolveArgs() {\n  _resolveArgs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(_runner, inputs, args) {\n    var runner, resolver;\n    return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n      while (1) switch (_context29.prev = _context29.next) {\n        case 0:\n          // Recursively descend into args and resolve any addresses\n          runner = getRunner(_runner, \"resolveName\");\n          resolver = canResolve(runner) ? runner : null;\n          _context29.next = 4;\n          return Promise.all(inputs.map(function (param, index) {\n            return param.walkAsync(args[index], function (type, value) {\n              value = Typed.dereference(value, type);\n              if (type === \"address\") {\n                return resolveAddress(value, resolver);\n              }\n              return value;\n            });\n          }));\n        case 4:\n          return _context29.abrupt(\"return\", _context29.sent);\n        case 5:\n        case \"end\":\n          return _context29.stop();\n      }\n    }, _callee29);\n  }));\n  return _resolveArgs.apply(this, arguments);\n}\nfunction buildWrappedFallback(contract) {\n  var populateTransaction = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(overrides) {\n      var tx, iface, noValue, noData, payable;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return copyOverrides(overrides, [\"data\"]);\n          case 2:\n            tx = _context2.sent;\n            _context2.next = 5;\n            return contract.getAddress();\n          case 5:\n            tx.to = _context2.sent;\n            iface = contract.interface;\n            noValue = getBigInt(tx.value || BN_0, \"overrides.value\") === BN_0;\n            noData = (tx.data || \"0x\") === \"0x\";\n            if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n              assertArgument(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n            }\n            assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n            // Only allow payable contracts to set non-zero value\n            payable = iface.receive || iface.fallback && iface.fallback.payable;\n            assertArgument(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n            // Only allow fallback contracts to set non-empty data\n            assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n            return _context2.abrupt(\"return\", tx);\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function populateTransaction(_x6) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var staticCall = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(overrides) {\n      var runner, tx;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"call\");\n            assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"call\"\n            });\n            _context3.next = 4;\n            return populateTransaction(overrides);\n          case 4:\n            tx = _context3.sent;\n            _context3.prev = 5;\n            _context3.next = 8;\n            return runner.call(tx);\n          case 8:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 11:\n            _context3.prev = 11;\n            _context3.t0 = _context3[\"catch\"](5);\n            if (!(isCallException(_context3.t0) && _context3.t0.data)) {\n              _context3.next = 15;\n              break;\n            }\n            throw contract.interface.makeError(_context3.t0.data, tx);\n          case 15:\n            throw _context3.t0;\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[5, 11]]);\n    }));\n    return function staticCall(_x7) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var send = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(overrides) {\n      var runner, tx, provider;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            runner = contract.runner;\n            assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"sendTransaction\"\n            });\n            _context4.t0 = runner;\n            _context4.next = 5;\n            return populateTransaction(overrides);\n          case 5:\n            _context4.t1 = _context4.sent;\n            _context4.next = 8;\n            return _context4.t0.sendTransaction.call(_context4.t0, _context4.t1);\n          case 8:\n            tx = _context4.sent;\n            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            return _context4.abrupt(\"return\", new ContractTransactionResponse(contract.interface, provider, tx));\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return function send(_x8) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var estimateGas = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(overrides) {\n      var runner;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"estimateGas\");\n            assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"estimateGas\"\n            });\n            _context5.t0 = runner;\n            _context5.next = 5;\n            return populateTransaction(overrides);\n          case 5:\n            _context5.t1 = _context5.sent;\n            _context5.next = 8;\n            return _context5.t0.estimateGas.call(_context5.t0, _context5.t1);\n          case 8:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 9:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return function estimateGas(_x9) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var method = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(overrides) {\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return send(overrides);\n          case 2:\n            return _context6.abrupt(\"return\", _context6.sent);\n          case 3:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    return function method(_x10) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  defineProperties(method, {\n    _contract: contract,\n    estimateGas: estimateGas,\n    populateTransaction: populateTransaction,\n    send: send,\n    staticCall: staticCall\n  });\n  return method;\n}\nfunction buildWrappedMethod(contract, key) {\n  var getFragment = function getFragment() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var fragment = contract.interface.getFunction(key, args);\n    assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\",\n      info: {\n        key: key,\n        args: args\n      }\n    });\n    return fragment;\n  };\n  var populateTransaction = /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      var _len2,\n        args,\n        _key2,\n        fragment,\n        overrides,\n        resolvedArgs,\n        _args7 = arguments;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            for (_len2 = _args7.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = _args7[_key2];\n            }\n            fragment = getFragment.apply(void 0, args); // If an overrides was passed in, copy it and normalize the values\n            overrides = {};\n            if (!(fragment.inputs.length + 1 === args.length)) {\n              _context7.next = 7;\n              break;\n            }\n            _context7.next = 6;\n            return copyOverrides(args.pop());\n          case 6:\n            overrides = _context7.sent;\n          case 7:\n            if (!(fragment.inputs.length !== args.length)) {\n              _context7.next = 9;\n              break;\n            }\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n          case 9:\n            _context7.next = 11;\n            return resolveArgs(contract.runner, fragment.inputs, args);\n          case 11:\n            resolvedArgs = _context7.sent;\n            _context7.t0 = Object;\n            _context7.t1 = {};\n            _context7.t2 = overrides;\n            _context7.next = 17;\n            return resolveProperties({\n              to: contract.getAddress(),\n              data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n            });\n          case 17:\n            _context7.t3 = _context7.sent;\n            return _context7.abrupt(\"return\", _context7.t0.assign.call(_context7.t0, _context7.t1, _context7.t2, _context7.t3));\n          case 19:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return function populateTransaction() {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  var staticCall = /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n      var result,\n        _args8 = arguments;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return staticCallResult.apply(void 0, _args8);\n          case 2:\n            result = _context8.sent;\n            if (!(result.length === 1)) {\n              _context8.next = 5;\n              break;\n            }\n            return _context8.abrupt(\"return\", result[0]);\n          case 5:\n            return _context8.abrupt(\"return\", result);\n          case 6:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8);\n    }));\n    return function staticCall() {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n  var send = /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n      var runner,\n        tx,\n        provider,\n        _args9 = arguments;\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            runner = contract.runner;\n            assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"sendTransaction\"\n            });\n            _context9.t0 = runner;\n            _context9.next = 5;\n            return populateTransaction.apply(void 0, _args9);\n          case 5:\n            _context9.t1 = _context9.sent;\n            _context9.next = 8;\n            return _context9.t0.sendTransaction.call(_context9.t0, _context9.t1);\n          case 8:\n            tx = _context9.sent;\n            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            return _context9.abrupt(\"return\", new ContractTransactionResponse(contract.interface, provider, tx));\n          case 11:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }));\n    return function send() {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n  var estimateGas = /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n      var runner,\n        _args10 = arguments;\n      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"estimateGas\");\n            assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"estimateGas\"\n            });\n            _context10.t0 = runner;\n            _context10.next = 5;\n            return populateTransaction.apply(void 0, _args10);\n          case 5:\n            _context10.t1 = _context10.sent;\n            _context10.next = 8;\n            return _context10.t0.estimateGas.call(_context10.t0, _context10.t1);\n          case 8:\n            return _context10.abrupt(\"return\", _context10.sent);\n          case 9:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10);\n    }));\n    return function estimateGas() {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n  var staticCallResult = /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n      var runner,\n        tx,\n        result,\n        fragment,\n        _args11 = arguments;\n      return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"call\");\n            assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"call\"\n            });\n            _context11.next = 4;\n            return populateTransaction.apply(void 0, _args11);\n          case 4:\n            tx = _context11.sent;\n            result = \"0x\";\n            _context11.prev = 6;\n            _context11.next = 9;\n            return runner.call(tx);\n          case 9:\n            result = _context11.sent;\n            _context11.next = 17;\n            break;\n          case 12:\n            _context11.prev = 12;\n            _context11.t0 = _context11[\"catch\"](6);\n            if (!(isCallException(_context11.t0) && _context11.t0.data)) {\n              _context11.next = 16;\n              break;\n            }\n            throw contract.interface.makeError(_context11.t0.data, tx);\n          case 16:\n            throw _context11.t0;\n          case 17:\n            fragment = getFragment.apply(void 0, _args11);\n            return _context11.abrupt(\"return\", contract.interface.decodeFunctionResult(fragment, result));\n          case 19:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, _callee11, null, [[6, 12]]);\n    }));\n    return function staticCallResult() {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n  var method = /*#__PURE__*/function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n      var fragment,\n        _args12 = arguments;\n      return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            fragment = getFragment.apply(void 0, _args12);\n            if (!fragment.constant) {\n              _context12.next = 5;\n              break;\n            }\n            _context12.next = 4;\n            return staticCall.apply(void 0, _args12);\n          case 4:\n            return _context12.abrupt(\"return\", _context12.sent);\n          case 5:\n            _context12.next = 7;\n            return send.apply(void 0, _args12);\n          case 7:\n            return _context12.abrupt(\"return\", _context12.sent);\n          case 8:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, _callee12);\n    }));\n    return function method() {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n  defineProperties(method, {\n    name: contract.interface.getFunctionName(key),\n    _contract: contract,\n    _key: key,\n    getFragment: getFragment,\n    estimateGas: estimateGas,\n    populateTransaction: populateTransaction,\n    send: send,\n    staticCall: staticCall,\n    staticCallResult: staticCallResult\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      var fragment = contract.interface.getFunction(key);\n      assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\",\n        info: {\n          key: key\n        }\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\nfunction buildWrappedEvent(contract, key) {\n  var getFragment = function getFragment() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    var fragment = contract.interface.getEvent(key, args);\n    assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\",\n      info: {\n        key: key,\n        args: args\n      }\n    });\n    return fragment;\n  };\n  var method = function method() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return new PreparedTopicFilter(contract, getFragment.apply(void 0, args), args);\n  };\n  defineProperties(method, {\n    name: contract.interface.getEventName(key),\n    _contract: contract,\n    _key: key,\n    getFragment: getFragment\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      var fragment = contract.interface.getEvent(key);\n      assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\",\n        info: {\n          key: key\n        }\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nvar internal = Symbol.for(\"_ethersInternal_contract\");\nvar internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n  internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n  return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n  return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nfunction getSubInfo(_x11, _x12) {\n  return _getSubInfo.apply(this, arguments);\n}\nfunction _getSubInfo() {\n  _getSubInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(contract, event) {\n    var topics, fragment, topicHashify, tag;\n    return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n      while (1) switch (_context30.prev = _context30.next) {\n        case 0:\n          fragment = null; // Convert named events to topicHash and get the fragment for\n          // events which need deconstructing.\n          if (!Array.isArray(event)) {\n            _context30.next = 6;\n            break;\n          }\n          topicHashify = function topicHashify(name) {\n            if (isHexString(name, 32)) {\n              return name;\n            }\n            var fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n          }; // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n          topics = event.map(function (e) {\n            if (e == null) {\n              return null;\n            }\n            if (Array.isArray(e)) {\n              return e.map(topicHashify);\n            }\n            return topicHashify(e);\n          });\n          _context30.next = 21;\n          break;\n        case 6:\n          if (!(event === \"*\")) {\n            _context30.next = 10;\n            break;\n          }\n          topics = [null];\n          _context30.next = 21;\n          break;\n        case 10:\n          if (!(typeof event === \"string\")) {\n            _context30.next = 14;\n            break;\n          }\n          if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [event];\n          } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n          }\n          _context30.next = 21;\n          break;\n        case 14:\n          if (!isDeferred(event)) {\n            _context30.next = 20;\n            break;\n          }\n          _context30.next = 17;\n          return event.getTopicFilter();\n        case 17:\n          topics = _context30.sent;\n          _context30.next = 21;\n          break;\n        case 20:\n          if (\"fragment\" in event) {\n            // ContractEvent; e.g. `contract.filter.Transfer`\n            fragment = event.fragment;\n            topics = [fragment.topicHash];\n          } else {\n            assertArgument(false, \"unknown event name\", \"event\", event);\n          }\n        case 21:\n          // Normalize topics and sort TopicSets\n          topics = topics.map(function (t) {\n            if (t == null) {\n              return null;\n            }\n            if (Array.isArray(t)) {\n              var items = Array.from(new Set(t.map(function (t) {\n                return t.toLowerCase();\n              })).values());\n              if (items.length === 1) {\n                return items[0];\n              }\n              items.sort();\n              return items;\n            }\n            return t.toLowerCase();\n          });\n          tag = topics.map(function (t) {\n            if (t == null) {\n              return \"null\";\n            }\n            if (Array.isArray(t)) {\n              return t.join(\"|\");\n            }\n            return t;\n          }).join(\"&\");\n          return _context30.abrupt(\"return\", {\n            fragment: fragment,\n            tag: tag,\n            topics: topics\n          });\n        case 24:\n        case \"end\":\n          return _context30.stop();\n      }\n    }, _callee30);\n  }));\n  return _getSubInfo.apply(this, arguments);\n}\nfunction hasSub(_x13, _x14) {\n  return _hasSub.apply(this, arguments);\n}\nfunction _hasSub() {\n  _hasSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(contract, event) {\n    var _getInternal5, subs;\n    return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n      while (1) switch (_context31.prev = _context31.next) {\n        case 0:\n          _getInternal5 = getInternal(contract), subs = _getInternal5.subs;\n          _context31.t1 = subs;\n          _context31.next = 4;\n          return getSubInfo(contract, event);\n        case 4:\n          _context31.t2 = _context31.sent.tag;\n          _context31.t0 = _context31.t1.get.call(_context31.t1, _context31.t2);\n          if (_context31.t0) {\n            _context31.next = 8;\n            break;\n          }\n          _context31.t0 = null;\n        case 8:\n          return _context31.abrupt(\"return\", _context31.t0);\n        case 9:\n        case \"end\":\n          return _context31.stop();\n      }\n    }, _callee31);\n  }));\n  return _hasSub.apply(this, arguments);\n}\nfunction getSub(_x15, _x16, _x17) {\n  return _getSub.apply(this, arguments);\n} // We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nfunction _getSub() {\n  _getSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(contract, operation, event) {\n    var provider, _yield$getSubInfo2, fragment, tag, topics, _getInternal6, addr, subs, sub, address, filter, listener, starting, start, stop;\n    return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n      while (1) switch (_context33.prev = _context33.next) {\n        case 0:\n          // Make sure our runner can actually subscribe to events\n          provider = getProvider(contract.runner);\n          assert(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n            operation: operation\n          });\n          _context33.next = 4;\n          return getSubInfo(contract, event);\n        case 4:\n          _yield$getSubInfo2 = _context33.sent;\n          fragment = _yield$getSubInfo2.fragment;\n          tag = _yield$getSubInfo2.tag;\n          topics = _yield$getSubInfo2.topics;\n          _getInternal6 = getInternal(contract), addr = _getInternal6.addr, subs = _getInternal6.subs;\n          sub = subs.get(tag);\n          if (!sub) {\n            address = addr ? addr : contract;\n            filter = {\n              address: address,\n              topics: topics\n            };\n            listener = function listener(log) {\n              var foundFragment = fragment;\n              if (foundFragment == null) {\n                try {\n                  foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n              }\n              // If fragment is null, we do not deconstruct the args to emit\n              if (foundFragment) {\n                var _foundFragment = foundFragment;\n                var _args32 = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                _emit4(contract, event, _args32, function (listener) {\n                  return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n              } else {\n                _emit4(contract, event, [], function (listener) {\n                  return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n              }\n            };\n            starting = [];\n            start = function start() {\n              if (starting.length) {\n                return;\n              }\n              starting.push(provider.on(filter, listener));\n            };\n            stop = /*#__PURE__*/function () {\n              var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n                var started;\n                return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n                  while (1) switch (_context32.prev = _context32.next) {\n                    case 0:\n                      if (!(starting.length == 0)) {\n                        _context32.next = 2;\n                        break;\n                      }\n                      return _context32.abrupt(\"return\");\n                    case 2:\n                      started = starting;\n                      starting = [];\n                      _context32.next = 6;\n                      return Promise.all(started);\n                    case 6:\n                      provider.off(filter, listener);\n                    case 7:\n                    case \"end\":\n                      return _context32.stop();\n                  }\n                }, _callee32);\n              }));\n              return function stop() {\n                return _ref17.apply(this, arguments);\n              };\n            }();\n            sub = {\n              tag: tag,\n              listeners: [],\n              start: start,\n              stop: stop\n            };\n            subs.set(tag, sub);\n          }\n          return _context33.abrupt(\"return\", sub);\n        case 12:\n        case \"end\":\n          return _context33.stop();\n      }\n    }, _callee33);\n  }));\n  return _getSub.apply(this, arguments);\n}\nvar lastEmit = Promise.resolve();\nfunction _emit(_x18, _x19, _x20, _x21) {\n  return _emit2.apply(this, arguments);\n}\nfunction _emit2() {\n  _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(contract, event, args, payloadFunc) {\n    var sub, count;\n    return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n      while (1) switch (_context34.prev = _context34.next) {\n        case 0:\n          _context34.next = 2;\n          return lastEmit;\n        case 2:\n          _context34.next = 4;\n          return hasSub(contract, event);\n        case 4:\n          sub = _context34.sent;\n          if (sub) {\n            _context34.next = 7;\n            break;\n          }\n          return _context34.abrupt(\"return\", false);\n        case 7:\n          count = sub.listeners.length;\n          sub.listeners = sub.listeners.filter(function (_ref18) {\n            var listener = _ref18.listener,\n              once = _ref18.once;\n            var passArgs = Array.from(args);\n            if (payloadFunc) {\n              passArgs.push(payloadFunc(once ? null : listener));\n            }\n            try {\n              listener.call.apply(listener, [contract].concat(passArgs));\n            } catch (error) {}\n            return !once;\n          });\n          if (sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(contract).subs.delete(sub.tag);\n          }\n          return _context34.abrupt(\"return\", count > 0);\n        case 11:\n        case \"end\":\n          return _context34.stop();\n      }\n    }, _callee34);\n  }));\n  return _emit2.apply(this, arguments);\n}\nfunction _emit4(_x22, _x23, _x24, _x25) {\n  return _emit3.apply(this, arguments);\n}\nfunction _emit3() {\n  _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(contract, event, args, payloadFunc) {\n    var resultPromise;\n    return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n      while (1) switch (_context35.prev = _context35.next) {\n        case 0:\n          _context35.prev = 0;\n          _context35.next = 3;\n          return lastEmit;\n        case 3:\n          _context35.next = 7;\n          break;\n        case 5:\n          _context35.prev = 5;\n          _context35.t0 = _context35[\"catch\"](0);\n        case 7:\n          resultPromise = _emit(contract, event, args, payloadFunc);\n          lastEmit = resultPromise;\n          _context35.next = 11;\n          return resultPromise;\n        case 11:\n          return _context35.abrupt(\"return\", _context35.sent);\n        case 12:\n        case \"end\":\n          return _context35.stop();\n      }\n    }, _callee35, null, [[0, 5]]);\n  }));\n  return _emit3.apply(this, arguments);\n}\nvar passProperties = [\"then\"];\nexport var BaseContract = /*#__PURE__*/function () {\n  /**\n   *  Creates a new contract connected to %%target%% with the %%abi%% and\n   *  optionally connected to a %%runner%% to perform operations on behalf\n   *  of.\n   */\n  function BaseContract(target, abi, runner, _deployTx) {\n    var _this = this;\n    _classCallCheck(this, BaseContract);\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    _defineProperty(this, \"target\", void 0);\n    /**\n     *  The contract Interface.\n     */\n    _defineProperty(this, \"interface\", void 0);\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    _defineProperty(this, \"runner\", void 0);\n    /**\n     *  All the Events available on this contract.\n     */\n    _defineProperty(this, \"filters\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, internal, void 0);\n    /**\n     *  The fallback or receive function if any.\n     */\n    _defineProperty(this, \"fallback\", void 0);\n    assertArgument(typeof target === \"string\" || isAddressable(target), \"invalid value for Contract target\", \"target\", target);\n    if (runner == null) {\n      runner = null;\n    }\n    var iface = Interface.from(abi);\n    defineProperties(this, {\n      target: target,\n      runner: runner,\n      interface: iface\n    });\n    Object.defineProperty(this, internal, {\n      value: {}\n    });\n    var addrPromise;\n    var addr = null;\n    var deployTx = null;\n    if (_deployTx) {\n      var provider = getProvider(runner);\n      // @TODO: the provider can be null; make a custom dummy provider that will throw a\n      // meaningful error\n      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);\n    }\n    var subs = new Map();\n    // Resolve the target as the address\n    if (typeof target === \"string\") {\n      if (isHexString(target)) {\n        addr = target;\n        addrPromise = Promise.resolve(target);\n      } else {\n        var resolver = getRunner(runner, \"resolveName\");\n        if (!canResolve(resolver)) {\n          throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n          });\n        }\n        addrPromise = resolver.resolveName(target).then(function (addr) {\n          if (addr == null) {\n            throw makeError(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n              value: target\n            });\n          }\n          getInternal(_this).addr = addr;\n          return addr;\n        });\n      }\n    } else {\n      addrPromise = target.getAddress().then(function (addr) {\n        if (addr == null) {\n          throw new Error(\"TODO\");\n        }\n        getInternal(_this).addr = addr;\n        return addr;\n      });\n    }\n    // Set our private values\n    setInternal(this, {\n      addrPromise: addrPromise,\n      addr: addr,\n      deployTx: deployTx,\n      subs: subs\n    });\n    // Add the event filters\n    var filters = new Proxy({}, {\n      get: function get(target, prop, receiver) {\n        // Pass important checks (like `then` for Promise) through\n        if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n          return Reflect.get(target, prop, receiver);\n        }\n        try {\n          return _this.getEvent(prop);\n        } catch (error) {\n          if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n            throw error;\n          }\n        }\n        return undefined;\n      },\n      has: function has(target, prop) {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return Reflect.has(target, prop) || _this.interface.hasEvent(String(prop));\n      }\n    });\n    defineProperties(this, {\n      filters: filters\n    });\n    defineProperties(this, {\n      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n    });\n    // Return a Proxy that will respond to functions\n    return new Proxy(this, {\n      get: function get(target, prop, receiver) {\n        if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Undefined properties should return undefined\n        try {\n          return target.getFunction(prop);\n        } catch (error) {\n          if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n            throw error;\n          }\n        }\n        return undefined;\n      },\n      has: function has(target, prop) {\n        if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return target.interface.hasFunction(prop);\n      }\n    });\n  }\n  /**\n   *  Return a new Contract instance with the same target and ABI, but\n   *  a different %%runner%%.\n   */\n  _createClass(BaseContract, [{\n    key: \"connect\",\n    value: function connect(runner) {\n      return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n  }, {\n    key: \"attach\",\n    value: function attach(target) {\n      return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n  }, {\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.next = 2;\n              return getInternal(this).addrPromise;\n            case 2:\n              return _context13.abrupt(\"return\", _context13.sent);\n            case 3:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getAddress() {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }()\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n  }, {\n    key: \"getDeployedCode\",\n    value: function () {\n      var _getDeployedCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var provider, code;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              provider = getProvider(this.runner);\n              assert(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getDeployedCode\"\n              });\n              _context14.t0 = provider;\n              _context14.next = 5;\n              return this.getAddress();\n            case 5:\n              _context14.t1 = _context14.sent;\n              _context14.next = 8;\n              return _context14.t0.getCode.call(_context14.t0, _context14.t1);\n            case 8:\n              code = _context14.sent;\n              if (!(code === \"0x\")) {\n                _context14.next = 11;\n                break;\n              }\n              return _context14.abrupt(\"return\", null);\n            case 11:\n              return _context14.abrupt(\"return\", code);\n            case 12:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function getDeployedCode() {\n        return _getDeployedCode.apply(this, arguments);\n      }\n      return getDeployedCode;\n    }()\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n  }, {\n    key: \"waitForDeployment\",\n    value: function () {\n      var _waitForDeployment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _this2 = this;\n        var deployTx, code, provider;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              // We have the deployement transaction; just use that (throws if deployement fails)\n              deployTx = this.deploymentTransaction();\n              if (!deployTx) {\n                _context16.next = 5;\n                break;\n              }\n              _context16.next = 4;\n              return deployTx.wait();\n            case 4:\n              return _context16.abrupt(\"return\", this);\n            case 5:\n              _context16.next = 7;\n              return this.getDeployedCode();\n            case 7:\n              code = _context16.sent;\n              if (!(code != null)) {\n                _context16.next = 10;\n                break;\n              }\n              return _context16.abrupt(\"return\", this);\n            case 10:\n              // Make sure we can subscribe to a provider event\n              provider = getProvider(this.runner);\n              assert(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"waitForDeployment\"\n              });\n              return _context16.abrupt(\"return\", new Promise(function (resolve, reject) {\n                var checkCode = /*#__PURE__*/function () {\n                  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n                    var _code;\n                    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n                      while (1) switch (_context15.prev = _context15.next) {\n                        case 0:\n                          _context15.prev = 0;\n                          _context15.next = 3;\n                          return _this2.getDeployedCode();\n                        case 3:\n                          _code = _context15.sent;\n                          if (!(_code != null)) {\n                            _context15.next = 6;\n                            break;\n                          }\n                          return _context15.abrupt(\"return\", resolve(_this2));\n                        case 6:\n                          provider.once(\"block\", checkCode);\n                          _context15.next = 12;\n                          break;\n                        case 9:\n                          _context15.prev = 9;\n                          _context15.t0 = _context15[\"catch\"](0);\n                          reject(_context15.t0);\n                        case 12:\n                        case \"end\":\n                          return _context15.stop();\n                      }\n                    }, _callee15, null, [[0, 9]]);\n                  }));\n                  return function checkCode() {\n                    return _ref13.apply(this, arguments);\n                  };\n                }();\n                checkCode();\n              }));\n            case 13:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function waitForDeployment() {\n        return _waitForDeployment.apply(this, arguments);\n      }\n      return waitForDeployment;\n    }()\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n  }, {\n    key: \"deploymentTransaction\",\n    value: function deploymentTransaction() {\n      return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(key) {\n      if (typeof key !== \"string\") {\n        key = key.format();\n      }\n      var func = buildWrappedMethod(this, key);\n      return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n  }, {\n    key: \"getEvent\",\n    value: function getEvent(key) {\n      if (typeof key !== \"string\") {\n        key = key.format();\n      }\n      return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n  }, {\n    key: \"queryTransaction\",\n    value: function () {\n      var _queryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(hash) {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              throw new Error(\"@TODO\");\n            case 1:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17);\n      }));\n      function queryTransaction(_x26) {\n        return _queryTransaction.apply(this, arguments);\n      }\n      return queryTransaction;\n    }()\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n         const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n         return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n  }, {\n    key: \"queryFilter\",\n    value: function () {\n      var _queryFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(event, fromBlock, toBlock) {\n        var _this3 = this;\n        var _getInternal, addr, addrPromise, address, _yield$getSubInfo, fragment, topics, filter, provider;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              if (fromBlock == null) {\n                fromBlock = 0;\n              }\n              if (toBlock == null) {\n                toBlock = \"latest\";\n              }\n              _getInternal = getInternal(this), addr = _getInternal.addr, addrPromise = _getInternal.addrPromise;\n              if (!addr) {\n                _context18.next = 7;\n                break;\n              }\n              _context18.t0 = addr;\n              _context18.next = 10;\n              break;\n            case 7:\n              _context18.next = 9;\n              return addrPromise;\n            case 9:\n              _context18.t0 = _context18.sent;\n            case 10:\n              address = _context18.t0;\n              _context18.next = 13;\n              return getSubInfo(this, event);\n            case 13:\n              _yield$getSubInfo = _context18.sent;\n              fragment = _yield$getSubInfo.fragment;\n              topics = _yield$getSubInfo.topics;\n              filter = {\n                address: address,\n                topics: topics,\n                fromBlock: fromBlock,\n                toBlock: toBlock\n              };\n              provider = getProvider(this.runner);\n              assert(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"queryFilter\"\n              });\n              _context18.next = 21;\n              return provider.getLogs(filter);\n            case 21:\n              return _context18.abrupt(\"return\", _context18.sent.map(function (log) {\n                var foundFragment = fragment;\n                if (foundFragment == null) {\n                  try {\n                    foundFragment = _this3.interface.getEvent(log.topics[0]);\n                  } catch (error) {}\n                }\n                if (foundFragment) {\n                  try {\n                    return new EventLog(log, _this3.interface, foundFragment);\n                  } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                  }\n                }\n                return new Log(log, provider);\n              }));\n            case 22:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function queryFilter(_x27, _x28, _x29) {\n        return _queryFilter.apply(this, arguments);\n      }\n      return queryFilter;\n    }()\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n  }, {\n    key: \"on\",\n    value: function () {\n      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return getSub(this, \"on\", event);\n            case 2:\n              sub = _context19.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: false\n              });\n              sub.start();\n              return _context19.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function on(_x30, _x31) {\n        return _on.apply(this, arguments);\n      }\n      return on;\n    }()\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n  }, {\n    key: \"once\",\n    value: function () {\n      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return getSub(this, \"once\", event);\n            case 2:\n              sub = _context20.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: true\n              });\n              sub.start();\n              return _context20.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function once(_x32, _x33) {\n        return _once.apply(this, arguments);\n      }\n      return once;\n    }()\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n  }, {\n    key: \"emit\",\n    value: function () {\n      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(event) {\n        var _len5,\n          args,\n          _key5,\n          _args21 = arguments;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              for (_len5 = _args21.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                args[_key5 - 1] = _args21[_key5];\n              }\n              _context21.next = 3;\n              return _emit4(this, event, args, null);\n            case 3:\n              return _context21.abrupt(\"return\", _context21.sent);\n            case 4:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function emit(_x34) {\n        return _emit5.apply(this, arguments);\n      }\n      return emit;\n    }()\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n  }, {\n    key: \"listenerCount\",\n    value: function () {\n      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(event) {\n        var sub, _getInternal2, subs, total, _iterator, _step, listeners;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              if (!event) {\n                _context22.next = 7;\n                break;\n              }\n              _context22.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context22.sent;\n              if (sub) {\n                _context22.next = 6;\n                break;\n              }\n              return _context22.abrupt(\"return\", 0);\n            case 6:\n              return _context22.abrupt(\"return\", sub.listeners.length);\n            case 7:\n              _getInternal2 = getInternal(this), subs = _getInternal2.subs;\n              total = 0;\n              _iterator = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  listeners = _step.value.listeners;\n                  total += listeners.length;\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context22.abrupt(\"return\", total);\n            case 12:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function listenerCount(_x35) {\n        return _listenerCount.apply(this, arguments);\n      }\n      return listenerCount;\n    }()\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n  }, {\n    key: \"listeners\",\n    value: function () {\n      var _listeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(event) {\n        var sub, _getInternal3, subs, result, _iterator2, _step2, _listeners2;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              if (!event) {\n                _context23.next = 7;\n                break;\n              }\n              _context23.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context23.sent;\n              if (sub) {\n                _context23.next = 6;\n                break;\n              }\n              return _context23.abrupt(\"return\", []);\n            case 6:\n              return _context23.abrupt(\"return\", sub.listeners.map(function (_ref14) {\n                var listener = _ref14.listener;\n                return listener;\n              }));\n            case 7:\n              _getInternal3 = getInternal(this), subs = _getInternal3.subs;\n              result = [];\n              _iterator2 = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  _listeners2 = _step2.value.listeners;\n                  result = result.concat(_listeners2.map(function (_ref15) {\n                    var listener = _ref15.listener;\n                    return listener;\n                  }));\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              return _context23.abrupt(\"return\", result);\n            case 12:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function listeners(_x36) {\n        return _listeners.apply(this, arguments);\n      }\n      return listeners;\n    }()\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n  }, {\n    key: \"off\",\n    value: function () {\n      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(event, listener) {\n        var sub, index;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return hasSub(this, event);\n            case 2:\n              sub = _context24.sent;\n              if (sub) {\n                _context24.next = 5;\n                break;\n              }\n              return _context24.abrupt(\"return\", this);\n            case 5:\n              if (listener) {\n                index = sub.listeners.map(function (_ref16) {\n                  var listener = _ref16.listener;\n                  return listener;\n                }).indexOf(listener);\n                if (index >= 0) {\n                  sub.listeners.splice(index, 1);\n                }\n              }\n              if (listener == null || sub.listeners.length === 0) {\n                sub.stop();\n                getInternal(this).subs.delete(sub.tag);\n              }\n              return _context24.abrupt(\"return\", this);\n            case 8:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function off(_x37, _x38) {\n        return _off.apply(this, arguments);\n      }\n      return off;\n    }()\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n  }, {\n    key: \"removeAllListeners\",\n    value: function () {\n      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(event) {\n        var sub, _getInternal4, subs, _iterator3, _step3, _step3$value, tag, stop;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              if (!event) {\n                _context25.next = 10;\n                break;\n              }\n              _context25.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context25.sent;\n              if (sub) {\n                _context25.next = 6;\n                break;\n              }\n              return _context25.abrupt(\"return\", this);\n            case 6:\n              sub.stop();\n              getInternal(this).subs.delete(sub.tag);\n              _context25.next = 13;\n              break;\n            case 10:\n              _getInternal4 = getInternal(this), subs = _getInternal4.subs;\n              _iterator3 = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _step3$value = _step3.value, tag = _step3$value.tag, stop = _step3$value.stop;\n                  stop();\n                  subs.delete(tag);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            case 13:\n              return _context25.abrupt(\"return\", this);\n            case 14:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function removeAllListeners(_x39) {\n        return _removeAllListeners.apply(this, arguments);\n      }\n      return removeAllListeners;\n    }()\n    /**\n     *  Alias for [on].\n     */\n  }, {\n    key: \"addListener\",\n    value: function () {\n      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return this.on(event, listener);\n            case 2:\n              return _context26.abrupt(\"return\", _context26.sent);\n            case 3:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function addListener(_x40, _x41) {\n        return _addListener.apply(this, arguments);\n      }\n      return addListener;\n    }()\n    /**\n     *  Alias for [off].\n     */\n  }, {\n    key: \"removeListener\",\n    value: function () {\n      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              _context27.next = 2;\n              return this.off(event, listener);\n            case 2:\n              return _context27.abrupt(\"return\", _context27.sent);\n            case 3:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n      function removeListener(_x42, _x43) {\n        return _removeListener.apply(this, arguments);\n      }\n      return removeListener;\n    }()\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n  }], [{\n    key: \"buildClass\",\n    value: function buildClass(abi) {\n      var CustomContract = /*#__PURE__*/function (_BaseContract) {\n        _inherits(CustomContract, _BaseContract);\n        var _super = _createSuper(CustomContract);\n        function CustomContract(address) {\n          var runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          _classCallCheck(this, CustomContract);\n          return _super.call(this, address, abi, runner);\n        }\n        return _createClass(CustomContract);\n      }(BaseContract);\n      return CustomContract;\n    }\n  }, {\n    key: \"from\",\n    value:\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    function from(target, abi, runner) {\n      if (runner == null) {\n        runner = null;\n      }\n      var contract = new this(target, abi, runner);\n      return contract;\n    }\n  }]);\n  return BaseContract;\n}();\nfunction _ContractBase() {\n  return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nexport var Contract = /*#__PURE__*/function (_ContractBase2) {\n  _inherits(Contract, _ContractBase2);\n  var _super2 = _createSuper(Contract);\n  function Contract() {\n    _classCallCheck(this, Contract);\n    return _super2.apply(this, arguments);\n  }\n  return _createClass(Contract);\n}(_ContractBase());","map":{"version":3,"names":["Interface","Typed","isAddressable","resolveAddress","copyRequest","Log","defineProperties","getBigInt","isCallException","isHexString","resolveProperties","isError","makeError","assert","assertArgument","ContractEventPayload","ContractUnknownEventPayload","ContractTransactionResponse","EventLog","UndecodedEventLog","BN_0","BigInt","canCall","value","call","canEstimate","estimateGas","canResolve","resolveName","canSend","sendTransaction","_filter","WeakMap","PreparedTopicFilter","contract","fragment","args","_classCallCheck","_classPrivateFieldInitSpec","writable","_defineProperty","inputs","length","Error","runner","getRunner","resolver","_classPrivateFieldSet","_asyncToGenerator","_regeneratorRuntime","mark","_callee","resolvedArgs","wrap","_callee$","_context","prev","next","Promise","all","map","param","index","arg","walkAsync","type","Array","isArray","v","sent","abrupt","interface","encodeFilterTopics","stop","_createClass","key","getTopicFilter","_classPrivateFieldGet","feature","provider","getProvider","copyOverrides","_x","_x2","_copyOverrides","apply","arguments","_callee28","allowed","_overrides","overrides","_callee28$","_context28","dereference","to","indexOf","data","from","resolveArgs","_x3","_x4","_x5","_resolveArgs","_callee29","_runner","_callee29$","_context29","buildWrappedFallback","populateTransaction","_ref2","_callee2","tx","iface","noValue","noData","payable","_callee2$","_context2","getAddress","fallback","receive","_x6","staticCall","_ref3","_callee3","_callee3$","_context3","operation","t0","_x7","send","_ref4","_callee4","_callee4$","_context4","t1","_x8","_ref5","_callee5","_callee5$","_context5","_x9","method","_ref6","_callee6","_callee6$","_context6","_x10","_contract","buildWrappedMethod","getFragment","_len","_key","getFunction","info","_ref7","_callee7","_len2","_key2","_args7","_callee7$","_context7","pop","Object","t2","encodeFunctionData","t3","assign","_ref8","_callee8","result","_args8","_callee8$","_context8","staticCallResult","_ref9","_callee9","_args9","_callee9$","_context9","_ref10","_callee10","_args10","_callee10$","_context10","_ref11","_callee11","_args11","_callee11$","_context11","decodeFunctionResult","_ref12","_callee12","_args12","_callee12$","_context12","constant","name","getFunctionName","defineProperty","configurable","enumerable","get","buildWrappedEvent","_len3","_key3","getEvent","_len4","_key4","getEventName","internal","Symbol","for","internalValues","setInternal","values","set","getInternal","isDeferred","getSubInfo","_x11","_x12","_getSubInfo","_callee30","event","topics","topicHashify","tag","_callee30$","_context30","topicHash","e","t","items","Set","toLowerCase","sort","join","hasSub","_x13","_x14","_hasSub","_callee31","_getInternal5","subs","_callee31$","_context31","getSub","_x15","_x16","_x17","_getSub","_callee33","_yield$getSubInfo2","_getInternal6","addr","sub","address","filter","listener","starting","start","_callee33$","_context33","log","foundFragment","error","_foundFragment","decodeEventLog","emit","push","on","_ref17","_callee32","started","_callee32$","_context32","off","listeners","lastEmit","resolve","_emit","_x18","_x19","_x20","_x21","_emit2","_callee34","payloadFunc","count","_callee34$","_context34","_ref18","once","passArgs","concat","delete","_x22","_x23","_x24","_x25","_emit3","_callee35","resultPromise","_callee35$","_context35","passProperties","BaseContract","target","abi","_deployTx","_this","addrPromise","deployTx","Map","then","filters","Proxy","prop","receiver","Reflect","argument","undefined","has","hasEvent","String","hasFunction","connect","attach","_getAddress","_callee13","_callee13$","_context13","_getDeployedCode","_callee14","code","_callee14$","_context14","getCode","getDeployedCode","_waitForDeployment","_callee16","_this2","_callee16$","_context16","deploymentTransaction","wait","reject","checkCode","_ref13","_callee15","_code","_callee15$","_context15","waitForDeployment","format","func","_queryTransaction","_callee17","hash","_callee17$","_context17","queryTransaction","_x26","_queryFilter","_callee18","fromBlock","toBlock","_this3","_getInternal","_yield$getSubInfo","_callee18$","_context18","getLogs","queryFilter","_x27","_x28","_x29","_on","_callee19","_callee19$","_context19","_x30","_x31","_once","_callee20","_callee20$","_context20","_x32","_x33","_emit5","_callee21","_len5","_key5","_args21","_callee21$","_context21","_x34","_listenerCount","_callee22","_getInternal2","total","_iterator","_step","_callee22$","_context22","_createForOfIteratorHelper","s","n","done","err","f","listenerCount","_x35","_listeners","_callee23","_getInternal3","_iterator2","_step2","_listeners2","_callee23$","_context23","_ref14","_ref15","_x36","_off","_callee24","_callee24$","_context24","_ref16","splice","_x37","_x38","_removeAllListeners","_callee25","_getInternal4","_iterator3","_step3","_step3$value","_callee25$","_context25","removeAllListeners","_x39","_addListener","_callee26","_callee26$","_context26","addListener","_x40","_x41","_removeListener","_callee27","_callee27$","_context27","removeListener","_x42","_x43","buildClass","CustomContract","_BaseContract","_inherits","_super","_createSuper","_ContractBase","Contract","_ContractBase2","_super2"],"sources":["C:\\Users\\prcue\\OneDrive\\Curso 4\\TFG GITT\\5. Desarrollo\\3. Frontend\\frontend_v3\\node_modules\\ethers\\src.ts\\contract\\contract.ts"],"sourcesContent":["import { Interface, Typed } from \"../abi/index.js\";\nimport { isAddressable, resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log, TransactionResponse } from \"../providers/provider.js\";\nimport {\n    defineProperties, getBigInt, isCallException, isHexString, resolveProperties,\n    isError, makeError, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport {\n    ContractEventPayload, ContractUnknownEventPayload,\n    ContractTransactionResponse,\n    EventLog, UndecodedEventLog\n} from \"./wrappers.js\";\n\nimport type { EventFragment, FunctionFragment, InterfaceAbi, ParamType, Result } from \"../abi/index.js\";\nimport type { Addressable } from \"../address/index.js\";\nimport type { EventEmitterable, Listener } from \"../utils/index.js\";\nimport type {\n    BlockTag, ContractRunner, Provider, TransactionRequest, TopicFilter\n} from \"../providers/index.js\";\n\nimport type {\n    BaseContractMethod,\n    ContractEventName,\n    ContractInterface,\n    ContractMethodArgs,\n    ContractMethod,\n    ContractEventArgs,\n    ContractEvent,\n    ContractTransaction,\n    DeferredTopicFilter,\n    WrappedFallback\n} from \"./types.js\";\n\nconst BN_0 = BigInt(0);\n\ninterface ContractRunnerCaller extends ContractRunner {\n    call: (tx: TransactionRequest) => Promise<string>;\n}\n\ninterface ContractRunnerEstimater extends ContractRunner {\n    estimateGas: (tx: TransactionRequest) => Promise<bigint>;\n}\n\ninterface ContractRunnerSender extends ContractRunner {\n    sendTransaction: (tx: TransactionRequest) => Promise<TransactionResponse>;\n}\n\ninterface ContractRunnerResolver extends ContractRunner {\n    resolveName: (name: string | Addressable) => Promise<null | string>;\n}\n\nfunction canCall(value: any): value is ContractRunnerCaller {\n    return (value && typeof(value.call) === \"function\");\n}\n\nfunction canEstimate(value: any): value is ContractRunnerEstimater {\n    return (value && typeof(value.estimateGas) === \"function\");\n}\n\nfunction canResolve(value: any): value is ContractRunnerResolver {\n    return (value && typeof(value.resolveName) === \"function\");\n}\n\nfunction canSend(value: any): value is ContractRunnerSender {\n    return (value && typeof(value.sendTransaction) === \"function\");\n}\n\nclass PreparedTopicFilter implements DeferredTopicFilter {\n    #filter: Promise<TopicFilter>;\n    readonly fragment!: EventFragment;\n\n    constructor(contract: BaseContract, fragment: EventFragment, args: Array<any>) {\n        defineProperties<PreparedTopicFilter>(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner: null;\n        this.#filter = (async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) { return null; }\n\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v) => resolveAddress(v, resolver)));\n                        }\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n\n    getTopicFilter(): Promise<TopicFilter> {\n        return this.#filter;\n    }\n}\n\n\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\n\nfunction getRunner<T extends ContractRunner>(value: any, feature: keyof ContractRunner): null | T {\n    if (value == null) { return null; }\n    if (typeof(value[feature]) === \"function\") { return value; }\n    if (value.provider && typeof(value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\n\nfunction getProvider(value: null | ContractRunner): null | Provider {\n    if (value == null) { return null; }\n    return value.provider || null;\n}\n\n/**\n *  @_ignore:\n */\nexport async function copyOverrides<O extends string = \"data\" | \"to\">(arg: any, allowed?: Array<string>): Promise<Omit<ContractTransaction, O>> {\n\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = Typed.dereference(arg, \"overrides\");\n    assertArgument(typeof(_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(_overrides);\n\n    assertArgument(overrides.to == null || (allowed || [ ]).indexOf(\"to\") >= 0,\n      \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || [ ]).indexOf(\"data\") >= 0,\n      \"cannot override data\", \"overrides.data\", overrides.data);\n\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = await resolveAddress(overrides.from);\n    }\n\n    return <Omit<ContractTransaction, O>>overrides;\n}\n\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner: null | ContractRunner, inputs: ReadonlyArray<ParamType>, args: Array<any>): Promise<Array<any>> {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner: null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") { return resolveAddress(value, resolver); }\n            return value;\n        });\n    }));\n}\n\nfunction buildWrappedFallback(contract: BaseContract): WrappedFallback {\n\n    const populateTransaction = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransaction> {\n        // If an overrides was passed in, copy it and normalize the values\n\n        const tx: ContractTransaction = <any>(await copyOverrides<\"data\">(overrides, [ \"data\" ]));\n        tx.to = await contract.getAddress();\n\n        const iface = contract.interface;\n\n        const noValue = (getBigInt((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            assertArgument(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n\n        assertArgument(iface.fallback || noData,\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || noValue,\n          \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || noData,\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        return tx;\n    }\n\n    const staticCall = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<string> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(overrides);\n\n        try {\n            return await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    }\n\n    const send = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(overrides));\n    }\n\n    const method = async (overrides?: Omit<TransactionRequest, \"to\">) => {\n        return await send(overrides);\n    };\n\n    defineProperties<any>(method, {\n        _contract: contract,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n\n    return <WrappedFallback>method;\n}\n\nfunction buildWrappedMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse>(contract: BaseContract, key: string): BaseContractMethod<A, R, D> {\n\n    const getFragment = function(...args: ContractMethodArgs<A>): FunctionFragment {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    }\n\n    const populateTransaction = async function(...args: ContractMethodArgs<A>): Promise<ContractTransaction> {\n        const fragment = getFragment(...args);\n\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides: Omit<ContractTransaction, \"data\" | \"to\"> = { };\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n\n        return Object.assign({ }, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    }\n\n    const staticCall = async function(...args: ContractMethodArgs<A>): Promise<R> {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) { return result[0]; }\n        return <R><unknown>result;\n    }\n\n    const send = async function(...args: ContractMethodArgs<A>): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(...args: ContractMethodArgs<A>): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(...args));\n    }\n\n    const staticCallResult = async function(...args: ContractMethodArgs<A>): Promise<Result> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(...args);\n\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n\n    const method = async (...args: ContractMethodArgs<A>) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) { return await staticCall(...args); }\n        return await send(...args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n\n        getFragment,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n\n    return <BaseContractMethod<A, R, D>>method;\n}\n\nfunction buildWrappedEvent<A extends Array<any> = Array<any>>(contract: BaseContract, key: string): ContractEvent<A> {\n\n    const getFragment = function(...args: ContractEventArgs<A>): EventFragment {\n        const fragment = contract.interface.getEvent(key, args);\n\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n\n        return fragment;\n    }\n\n    const method = function(...args: ContractMethodArgs<A>): PreparedTopicFilter {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n\n        getFragment\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n\n            return fragment;\n        }\n    });\n\n    return <ContractEvent<A>><unknown>method;\n}\n\ntype Sub = {\n    tag: string;\n    listeners: Array<{ listener: Listener, once: boolean }>,\n    start: () => void;\n    stop: () => void;\n};\n\n\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\n\nconst internal = Symbol.for(\"_ethersInternal_contract\");\ntype Internal = {\n    addrPromise: Promise<string>;\n    addr: null | string;\n\n    deployTx: null | ContractTransactionResponse;\n\n    subs: Map<string, Sub>;\n};\n\nconst internalValues: WeakMap<BaseContract, Internal> = new WeakMap();\n\nfunction setInternal(contract: BaseContract, values: Internal): void {\n    internalValues.set(contract[internal], values);\n}\n\nfunction getInternal(contract: BaseContract): Internal {\n    return internalValues.get(contract[internal]) as Internal;\n}\n\nfunction isDeferred(value: any): value is DeferredTopicFilter {\n    return (value && typeof(value) === \"object\" && (\"getTopicFilter\" in value) &&\n      (typeof(value.getTopicFilter) === \"function\") && value.fragment);\n}\n\nasync function getSubInfo(contract: BaseContract, event: ContractEventName): Promise<{ fragment: null | EventFragment, tag: string, topics: TopicFilter }> {\n    let topics: Array<null | string | Array<string>>;\n    let fragment: null | EventFragment = null;\n\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n\n    if (Array.isArray(event)) {\n        const topicHashify = function(name: string): string {\n            if (isHexString(name, 32)) { return name; }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        }\n\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) { return null; }\n            if (Array.isArray(e)) { return e.map(topicHashify); }\n            return topicHashify(e);\n        });\n\n    } else if (event === \"*\") {\n        topics = [ null ];\n\n    } else if (typeof(event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [ event ];\n        } else {\n           // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [ fragment.topicHash ];\n        }\n\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [ fragment.topicHash ];\n\n    } else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) { return null; }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) { return items[0]; }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n\n    const tag = topics.map((t) => {\n        if (t == null) { return \"null\"; }\n        if (Array.isArray(t)) { return t.join(\"|\"); }\n        return t;\n    }).join(\"&\");\n\n    return { fragment, tag, topics }\n}\n\nasync function hasSub(contract: BaseContract, event: ContractEventName): Promise<null | Sub> {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\n\nasync function getSub(contract: BaseContract, operation: string, event: ContractEventName): Promise<Sub> {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\",\n        \"UNSUPPORTED_OPERATION\", { operation });\n\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n\n    const { addr, subs } = getInternal(contract);\n\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address: string | Addressable = (addr ? addr: contract);\n        const filter = { address, topics };\n        const listener = (log: Log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            // If fragment is null, we do not deconstruct the args to emit\n\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics): [ ];\n                emit(contract, event, args, (listener: null | Listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [ ], (listener: null | Listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n\n        let starting: Array<Promise<any>> = [ ];\n        const start = () => {\n            if (starting.length) { return; }\n            starting.push(provider.on(filter, listener));\n        };\n\n        const stop = async () => {\n            if (starting.length == 0) { return; }\n\n            let started = starting;\n            starting = [ ];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n\n        sub = { tag, listeners: [ ], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit: Promise<any> = Promise.resolve();\n\ntype PayloadFunc = (listener: null | Listener) => ContractUnknownEventPayload;\n\nasync function _emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    await lastEmit;\n\n    const sub = await hasSub(contract, event);\n    if (!sub) { return false; }\n\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null: listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) { }\n        return !once;\n    });\n\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n\n    return (count > 0);\n}\n\nasync function emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    try {\n        await lastEmit;\n    } catch (error) { }\n\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\n\nconst passProperties = [ \"then\" ];\nexport class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    readonly target!: string | Addressable;\n\n    /**\n     *  The contract Interface.\n     */\n    readonly interface!: Interface;\n\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    readonly runner!: null | ContractRunner;\n\n    /**\n     *  All the Events available on this contract.\n     */\n    readonly filters!: Record<string, ContractEvent>;\n\n    /**\n     *  @_ignore:\n     */\n    readonly [internal]: any;\n\n    /**\n     *  The fallback or receive function if any.\n     */\n    readonly fallback!: null | WrappedFallback;\n\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target: string | Addressable, abi: Interface | InterfaceAbi, runner?: null | ContractRunner, _deployTx?: null | TransactionResponse) {\n        assertArgument(typeof(target) === \"string\" || isAddressable(target),\n            \"invalid value for Contract target\", \"target\", target);\n\n        if (runner == null) { runner = null; }\n        const iface = Interface.from(abi);\n        defineProperties<BaseContract>(this, { target, runner, interface: iface });\n\n        Object.defineProperty(this, internal, { value: { } });\n\n        let addrPromise;\n        let addr: null | string = null;\n\n        let deployTx: null | ContractTransactionResponse = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, <Provider>provider, _deployTx);\n        }\n\n        let subs = new Map();\n\n        // Resolve the target as the address\n        if (typeof(target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw makeError(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) { throw new Error(\"TODO\"); }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n\n        // Add the event filters\n        const filters = new Proxy({ }, {\n            get: (target, prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (typeof(prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n\n                return undefined;\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        defineProperties<BaseContract>(this, { filters });\n\n        defineProperties<BaseContract>(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)): null)\n        });\n\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof(prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n\n                return undefined;\n            },\n            has: (target, prop) => {\n                if (typeof(prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return target.interface.hasFunction(prop);\n            }\n        });\n\n    }\n\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner: null | ContractRunner): BaseContract {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target: string | Addressable): BaseContract {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress(): Promise<string> { return await getInternal(this).addrPromise; }\n\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode(): Promise<null | string> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") { return null; }\n        return code;\n    }\n\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment(): Promise<this> {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) { return this; }\n\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) { return resolve(this); }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction(): null | ContractTransactionResponse {\n        return getInternal(this).deployTx;\n    }\n\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        const func = buildWrappedMethod(this, key);\n        return <T>func;\n    }\n\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key: string | EventFragment): ContractEvent {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        return buildWrappedEvent(this, key);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash: string): Promise<Array<EventLog>> {\n        throw new Error(\"@TODO\");\n    }\n\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event: ContractEventName, fromBlock?: BlockTag, toBlock?: BlockTag): Promise<Array<EventLog | Log>> {\n        if (fromBlock == null) { fromBlock = 0; }\n        if (toBlock == null) { toBlock = \"latest\"; }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr: (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            if (foundFragment) {\n                try {\n                    return new EventLog(log, this.interface, foundFragment);\n                } catch (error: any) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n\n            return new Log(log, provider);\n        });\n    }\n\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event: ContractEventName, ...args: Array<any>): Promise<boolean> {\n        return await emit(this, event, args, null);\n    }\n\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event?: ContractEventName): Promise<number> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        const { subs } = getInternal(this);\n\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event?: ContractEventName): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n\n        const { subs } = getInternal(this);\n\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event: ContractEventName, listener?: Listener): Promise<this> {\n        const sub = await hasSub(this, event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event?: ContractEventName): Promise<this> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return this; }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.on(event, listener);\n    }\n\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.off(event, listener);\n    }\n\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass<T = ContractInterface>(abi: Interface | InterfaceAbi): new (target: string, runner?: null | ContractRunner) => BaseContract & Omit<T, keyof BaseContract> {\n        class CustomContract extends BaseContract {\n            constructor(address: string, runner: null | ContractRunner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract as any;\n    };\n\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from<T = ContractInterface>(target: string, abi: Interface | InterfaceAbi, runner?: null | ContractRunner): BaseContract & Omit<T, keyof BaseContract> {\n        if (runner == null) { runner = null; }\n        const contract = new this(target, abi, runner );\n        return contract as any;\n    }\n}\n\nfunction _ContractBase(): new (target: string, abi: Interface | InterfaceAbi, runner?: null | ContractRunner) => BaseContract & Omit<ContractInterface, keyof BaseContract> {\n    return BaseContract as any;\n}\n\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nexport class Contract extends _ContractBase() { }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}